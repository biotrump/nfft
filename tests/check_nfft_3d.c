/*
 * Copyright (c) 2002, 2012 Jens Keiner, Stefan Kunis, Daniel Potts
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* $Id: simple_test.c 3509 2010-05-25 19:00:59Z keiner $ */

/* Standard headers. */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

#include "nfft3util.h"
#include "nfft3.h"
#include "infft.h"

static const R x[] =
{
  K(+0.3036378174651077887097550870104819626075767806604220754729509657),
  K(-0.2526549522442642162063744136205337633072118370803534984182466225),
  K(-0.2200060933955098538316706462767013232758020996338717389233295203),
  K(+0.4024793254944456063365665630120210683630055988032530390391638116),
  K(-0.3270067880479954428091571104459628541984300344172362348548287473),
  K(+0.1853483806406433608760758698082798958945570629259099925606591621),
  K(-0.3121305015265552790372942825378428532095987557134517634676566476),
  K(+0.04215331657313689728460556808853816393741236591770612058320007574),
  K(-0.3666361160138952729598349383112187130897717901585411768382089531),
  K(+0.4791618778429663475856107006916230501736038790195693849478252115),
};

static const C f_hat[] =
{
  K(+0.8342691439273211194521982876007150313213380811664346920809744750) + K(-0.5109527063162827920347418403486535138183416864655058039385918496) * I,
  K(-0.5835857075924637998732669463122424141722729073950187882736305868) + K(+0.8554670763218709269387514277190849877583971420121620732708504804) * I,
  K(-0.8328901755993130402356798460818647034757813784197826666857585133) + K(-0.7000703809212678208528818545884416070561443617354999864651762717) * I,
  K(+0.6950126644280140714202099068562614227920775680170273962988199626) + K(+0.4723038856419898118794441062368581965595944604122811531937710945) * I,
  K(+0.8403877277157755008317482556983588954528710777643063728496759787) + K(-0.5658294869273196939224075758396433088498969484862175257856071369) * I,
  K(-0.2536736224753843043250129375340517878327501684522438259212355381) + K(+0.4409861011455457734786141729577228914926360007483522684316736471) * I,
  K(-0.9878330560427861967478233100522962371491814866547079797551073541) + K(-0.9838117854612704943871959575641873696649220836817149131883399441) * I,
  K(+0.1880010805684618234456673307624244583803773446864613129526782391) + K(+0.5578830060460536047061865903347679430750128946200672450575623128) * I,
  K(+0.1099317645701760278695672677798258298666765103098991930238962565) + K(+0.7169109651436524574851527660442099044484163196009643460579741955) * I,
  K(+0.01978331643474399711914092028138436183918558890853730527771681728) + K(-0.7451028017835829065440269600094345785666502128526133812457455971) * I,
};

static const C f[] =
{
  K(-5.28038011782799434317647473959161342240798596062360626506110768) + K(+1.92072089257587386807077872727137591437193486004194842374861919) * I,
  K(-0.36842274091872166051675723901884372997920757249258600220206085) + K(-3.95308295605448347900843484387936795846602870516701678920092100) * I,
  K(-0.27155408702038649129253638210649078986753894522282110024802530) + K(-4.83110704548291052710956427902248296068109159755041012420730221) * I,
  K(+3.34620377495975845427582402426511351864593453012443485910122049) + K(+1.58170931292233927984847624708052839950766297293609185363062635) * I,
  K(+0.73347257423661376283765311740049695078529369970781235617886897) + K(+0.76938290489464201649962131970881938219341645961509242780635233) * I,
  K(+1.09798559328147009719646132166370111418007781880650266059508660) + K(+1.24522431193061198903682132291058729551563499806691127992263126) * I,
  K(+0.51818886990165567763526077365936666011224429261177687334200208) + K(+0.00263355352261969067472079543296173460266176613085631143431049) * I,
  K(-0.16818575847031496109919700879482504542061325765274725256468629) + K(+0.12037039707435908688870717558707808274135098677546719007297344) * I,
  K(+0.47531448828599865401849125458981560127425921836002408571200794) + K(+1.56812633827127935897685996005448345666898028390436475901550476) * I,
  K(+1.84050609197692872935152789247113425612099830045791325988311716) + K(+4.01403313255276561358272020106649891240948383494034607422242159) * I,
};

static void check_nfft_1d(void)
{
  const int M = sizeof(x)/sizeof(x[0]);
  const int N = sizeof(f_hat)/sizeof(f_hat[0]);
  X(plan) p;
  int j;
  
  X(init_1d)(&p, N, M);

  /* Nodes. */
  for (j = 0; j < M; j++)
    p.x[j] = x[j];

  /* Pre-compute Psi. */
  if(p.nfft_flags & PRE_ONE_PSI)
    X(precompute_one_psi)(&p);

  /* Fourier coefficients. */
  for (j = 0; j < N; j++)
    p.f_hat[j] = f_hat[j];

  X(trafo)(&p);

  /* debug */
  /*for (j = 0; j < M; j++)
    fprintf(stderr, "f[%2d] = " FE_ " f[%2d] = " FE_ " err = " FE_ "\n", j,
      CREAL(f[j]), j, CREAL(p.f[j]), CABS(f[j] - p.f[j]) / CABS(f[j]));*/

  /* Standard NFFT error measure. */
  {
    R numerator = K(0.0);
    R denominator = K(0.0);
    for (j = 0; j < M; j++)
      numerator = MAX(numerator, CABS(f[j] - p.f[j]));
    for (j = 0; j < N; j++)
      denominator += CABS(f_hat[j]);
    printf(FE_ "\n", numerator/denominator);
  }
}

int main(void)
{
  check_nfft_1d();
  return EXIT_SUCCESS;
}
