fastsumS2 - Fast summation of radial functions on the sphere

  Introduction
  ------------

  This example deals with approximations to sums of the form

            L-1
             -
  f(xi_d) =  >  b_l  K(eta_l - xi_d)    (d=0,...,D-1)                    (1)
             -
            l=0

  where xi_d, eta_l are arbitrary nodes on the sphere S^2 given in spherical 
  coordinates (theta,phi) from [0,pi] x [-pi,pi), b_l are complex coefficients 
  and K: [-1,1] -> C is a kernel function. Such kernels include the Abel-Poisson
  and singularity kernels as well as locally supported kernels and the spherical
  Gaussian kernel. See for example [1].

  The fast approximate algorithm used is based on the fast spherical Fourier
  transform for arbitrary nodes (NFSFT). For more informtion on the algorithm
  and notation in detail, we refer to [1] and [2]. Alternatively, once can
  replace the individual steps of the NFSFT algirithm by exact but
  asymptotically slower algorithms or use a direct evaluation and summation of
  the kernel functions in (1).

  Directory contents
  ------------------

  fastsumS2.c     Example C program
  README          This file
  Makefile.am     Automake template
  fastsumS2.m     Matlab example file that preproduces figures from [1] using
                  fastsumS2.c
  readTestcase.m  Matlab function that reads output of fastsumS2.c
  writeTestcase.m Matlab function that writes input for fastsumS2.c

  fastsumS2.C
  -----------
  The C program fastsumS2.c computes approximations of the sums in (1) using the
  different algorithms. It takes input from the standard input stream and writes
  output to the standard output stream. The input consists of one ore more
  testcases. Each testcase specifies
  - the algorithm(s) and their parameters to be used,
  - the kernel function and their parameters to be used,
  - the cut-off degrees M for the kernel function,
  - the numbers D and L of nodes to be used.
  The nodes xi_d and eta_l are chosen uniformly randomly distributed over the
  sphere S^2. The coefficients b_l are chosen uniformly randomly distributed
  in the complex square [-1/2,1/2] x [-1/2,1/2]i.

  Example input:

  testcases=2

  nfsft=1
  nfft=0
  fpt=1
  threshold=1.000000e+03
  kernel=0
  parameter_sets=1
  parameters=3
  0.800000
  0.700000
  0.600000
  bandwidths=4
  16
  32
  64
  128
  node_sets=2
  L=1000
  D=1000
  compare=1
  precomputed=0
  repetitions=1
  L=2000
  D=2000
  compare=0

  nfsft=0
  kernel=0
  parameter_sets=1
  parameters=2
  0.700000
  0.600000
  bandwidths=4
  16
  32
  64
  128
  node_sets=1
  L=1000
  D=1000
  compare=1
  precomputed=0
  repetitions=1

  Each parameter is specified by an assignment of the form 'name=value'. All
  parameter values are integer or floating point numbers. There are basic
  parameters which have to be specified in every testcase and extra parameters
  which are only added if the parameters on which each of them depends take
  certain values. The parameters must be specified in order as above. Every
  parameter has a range of admissible values. The behaviour of the program for
  illegal values of parameters is unspecified. The first parameter specification
  is 'testcases=...' which specifies the number of testcases to follow. Each
  testcase has the following parameters with extra parameters marked by an
  asterisk:
  - nfsft If set to 1, the NFSFT algorithm is used. If set to 0, the direct
    NDSFT algorithm is used.
  * nfft If set to 1, the NFSFT algorithm will internally use the NFFT
    algorithm. If set to 0, the NFSFT algorithm will instead use the direct
    NDSFT algorithm. Extra parameter. Specified only if nfsft=1.
  * cutoff An integer > 0 specifying the NFFT cut-off parameter. Extra
    parameter. Specified only if nfft=1.
  * fpt If set to 1, the NFSFT algorithm will internally use the fast polynomial
    transform algorithm (FPT). If set to 0, the NFSFT algorithm will instead
    use the direct discrete polynomial transform algorithm (direct DPT). Extra
    parameter. Specified only if nfsft=1.
  * threshold A floating point number > 0 specifying the threshold parameter for
    the FPT algorithm. Extra parameter. Specified only if fpt=1.
  - kernel An integer from {0,1,2,3} specifying the type of kernel function
    to be used. The different kernel functions available are
    + the Abel-Poisson kernel Q_h with real parameter h from (0,1),
    + the singularity kernel S_h with real parameter h from (0,1),
    + the locally supported kernel L_h,lambda real parameter h from (-1,1) and
      integer parameter lambda >= 0.
    + the spherical Gaussian kernel G_sigma with real parameter sigma > 0.
  - parameter_sets An integer > 0 specifying the number of parameter sets to
    follow for the chosen type of kernel function. In a testcase, the specified
    type of kernel function can be used with more than one set of distinct
    parameters to yield different kernel functions.
  - parameters An integer > 0 specifying the number of parameters that specifies
    each individual kernel function (one for Abel-Poisson, singularity and
    spherical Gaussian kernel, two for the locally supported kernel). The
    parameters' values are given afterwards a list floating point
    numbers order as in the description of the kernel functions above and
    grouped by kernel function instance.
  - bandwidths The number of different cut-off degrees M to be used in the
    approximation. There follows a list of positive integers specifying the
    distinct cut-off degrees.
  - node_sets An integer > 0 specifying the number of sets of nodes to follow
  - L An integer > 0 specifying the number of source nodes.
  - D An integer > 0 specifying the number of target nodes.
  - compare If set to 1, the result of the approximate algorithm is compared to
    the result of the direct evaluation. If set to 0, no comparison is
    performed.
  * precomputed If set to 1, all values in the sum (1) are precomputed and the
    time measurement for the direct evaluation only measures the time needed to
    sum up these values. Extra parameter. Specified only if compare=1.
  * repetitions And integer > 0 specifying the number of times the summation
    process is repeated. Time emasurements are averaged over all repetitions.
    This can be used to compensate for inaccuracies in the time measurements for
    very small computation times.

  The output of the program containes all the input but without the parameter
  names and in addition the results of time and error measurements

  Example output

  2
  1
  0
  1
  1000.000000
  0
  1
  3
  0.800000
  0.700000
  0.600000
  4
  16
  32
  64
  128
  2
  1000
  1000
  1
  0
  1
  2000
  2000
  0
  4.649290e-01
  -1.000000e+00
  -1.000000e+00
  3.439480e-01
  -1.000000e+00
  4.652502e-03

  4.649290e-01
  -1.000000e+00
  -1.000000e+00
  1.310801e+00
  -1.000000e+00
  1.512698e-04

  4.649290e-01
  -1.000000e+00
  -1.000000e+00
  5.215208e+00
  -1.000000e+00
  2.175886e-07

  4.649290e-01
  -1.000000e+00
  -1.000000e+00
  2.071185e+01
  -1.000000e+00
  1.785035e-13

  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  6.868950e-01
  -1.000000e+00
  -1.000000e+00

  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  2.616603e+00
  -1.000000e+00
  -1.000000e+00

  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  1.032143e+01
  -1.000000e+00
  -1.000000e+00

  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  4.086879e+01
  -1.000000e+00
  -1.000000e+00

  0
  0
  1
  2
  0.700000
  0.600000
  4
  16
  32
  64
  128
  1
  1000
  1000
  1
  0
  1
  4.629290e-01
  -1.000000e+00
  2.899600e-02
  -1.000000e+00
  2.455525e-04
  -1.000000e+00

  4.629290e-01
  -1.000000e+00
  6.999000e-02
  -1.000000e+00
  1.328986e-06
  -1.000000e+00

  4.629290e-01
  -1.000000e+00
  2.039690e-01
  -1.000000e+00
  1.611595e-11
  -1.000000e+00

  4.629290e-01
  -1.000000e+00
  1.353794e+00
  -1.000000e+00
  6.555554e-16
  -1.000000e+00



  References:

  [1] Keiner, J., Kunis, S. and Potts, D., Fast summation of radial functions 
      on the sphere, Computing, to appear, 2005

  [2] Kunis, S. and Potts, D., Fast spherical Fourier algorithms, J. Comput.
      Appl. Math. 161, 75-98, 2003

