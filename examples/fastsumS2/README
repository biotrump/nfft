fastsumS2 - Fast summation of radial functions on the sphere

  Introduction
  ------------

  This example deals with approximations to sums of the form

            L-1
             -
  f(xi_d) =  >  b_l  K(eta_l - xi_d)    (d=0,...,D-1)                    (1)
             -
            l=0

  where xi_d, eta_l are arbitrary nodes on the sphere S^2 given in spherical 
  coordinates (theta,phi) from [0,pi] x [-pi,pi), b_l are complex coefficients 
  and K: [-1,1] -> C is a kernel function. Such kernels include the Abel-Poisson
  and singularity kernels as well as locally supported kernels and the spherical
  Gaussian kernel. See for example [1].

  The fast approximate algorithm used is based on the fast spherical Fourier
  transform for arbitrary nodes (NFSFT). For more informtion on the algorithm
  and notation in detail, we refer to [1] and [2]. Alternatively, once can
  replace the individual steps of the NFSFT algirithm by exact but
  asymptotically slower algorithms or use a direct evaluation and summation of
  the kernel functions in (1).

  Directory contents
  ------------------

  fastsumS2.c     Example C program
  README          This file
  Makefile.am     Automake template
  fastsumS2.m     Matlab example file that preproduces figures from [1] using
                  fastsumS2.c
  readTestcase.m  Matlab function that reads output of fastsumS2.c
  writeTestcase.m Matlab function that writes input for fastsumS2.c

  fastsumS2.C
  -----------
  The C program fastsumS2.c computes approximations of the sums in (1) using the
  different algorithms. It takes input from the standard input stream and writes
  output to the standard output stream. The input consists of one ore more
  testcases. Each testcase specifies
  - the algorithm(s) and their parameters to be used,
  - the kernel function and their parameters to be used,
  - the cut-off degrees M for the kernel function,
  - the numbers D and L of nodes to be used.
  The nodes xi_d and eta_l are chosen uniformly randomly distributed over the
  sphere S^2. The coefficients b_l are chosen uniformly randomly distributed
  in the complex square [-1/2,1/2] x [-1/2,1/2]i.

  Example input:

  testcases=2

  nfsft=1
  nfft=0
  fpt=1
  threshold=1.000000e+03
  kernel=0
  parameter_sets=3
  parameters=1
  0.800000
  0.700000
  0.600000
  bandwidths=4
  16
  32
  64
  128
  node_sets=2
  L=1000
  D=1000
  compare=1
  precomputed=0
  repetitions=1
  L=2000
  D=2000
  compare=0

  nfsft=0
  kernel=0
  parameter_sets=2
  parameters=1
  0.700000
  0.600000
  bandwidths=4
  16
  32
  64
  128
  node_sets=1
  L=1000
  D=1000
  compare=1
  precomputed=0
  repetitions=1

  Each parameter is specified by an assignment of the form 'name=value'. All
  parameter values are integer or floating point numbers. There are basic
  parameters which have to be specified in every testcase and extra parameters
  which are only added if the parameters on which each of them depends take
  certain values. The parameters must be specified in order as above. Every
  parameter has a range of admissible values. The behaviour of the program for
  illegal values of parameters is unspecified. The first parameter specification
  is 'testcases=...' which specifies the number of testcases to follow. Each
  testcase has the following parameters with extra parameters marked by an
  asterisk:
  - nfsft If set to 1, the NFSFT algorithm is used. If set to 0, the direct
    NDSFT algorithm is used.
  * nfft If set to 1, the NFSFT algorithm will internally use the NFFT
    algorithm. If set to 0, the NFSFT algorithm will instead use the direct
    NDSFT algorithm. Extra parameter. Specified only if nfsft=1.
  * cutoff An integer > 0 specifying the NFFT cut-off parameter. Extra
    parameter. Specified only if nfft=1.
  * fpt If set to 1, the NFSFT algorithm will internally use the fast polynomial
    transform algorithm (FPT). If set to 0, the NFSFT algorithm will instead
    use the direct discrete polynomial transform algorithm (direct DPT). Extra
    parameter. Specified only if nfsft=1.
  * threshold A floating point number > 0 specifying the threshold parameter for
    the FPT algorithm. Extra parameter. Specified only if fpt=1.
  - kernel An integer from {0,1,2,3} specifying the type of kernel function
    to be used. The different kernel functions available are
    + the Abel-Poisson kernel Q_h with real parameter h from (0,1),
    + the singularity kernel S_h with real parameter h from (0,1),
    + the locally supported kernel L_h,lambda real parameter h from (-1,1) and
      integer parameter lambda >= 0.
    + the spherical Gaussian kernel G_sigma with real parameter sigma > 0.
  - parameter_sets An integer > 0 specifying the number of parameter sets to
    follow for the chosen type of kernel function. In a testcase, the specified
    type of kernel function can be used with more than one set of distinct
    parameters to yield different kernel functions.
  - parameters An integer > 0 specifying the number of parameters that specifies
    each individual kernel function (one for Abel-Poisson, singularity and
    spherical Gaussian kernel, two for the locally supported kernel). The
    parameters' values are given afterwards a list floating point
    numbers order as in the description of the kernel functions above and
    grouped by kernel function instance.
  - bandwidths The number of different cut-off degrees M to be used in the
    approximation. There follows a list of positive integers specifying the
    distinct cut-off degrees.
  - node_sets An integer > 0 specifying the number of sets of nodes to follow
  - L An integer > 0 specifying the number of source nodes.
  - D An integer > 0 specifying the number of target nodes.
  - compare If set to 1, the result of the approximate algorithm is compared to
    the result of the direct evaluation. If set to 0, no comparison is
    performed.
  * precomputed If set to 1, all values in the sum (1) are precomputed and the
    time measurement for the direct evaluation only measures the time needed to
    sum up these values. Extra parameter. Specified only if compare=1.
  * repetitions And integer > 0 specifying the number of times the summation
    process is repeated. Time emasurements are averaged over all repetitions.
    This can be used to compensate for inaccuracies in the time measurements for
    very small computation times.

  The output of the program containes all the input but without the parameter
  names and, in addition, the results of time and error measurements after each
  testcase.

  Example output (see example input from above):

  2
  1
  0
  1
  1000.000000
  0
  3
  1
  0.800000
  0.700000
  0.600000
  4
  16
  32
  64
  128
  2
  1000
  1000
  1
  0
  1
  2000
  2000
  0
  5.399180e-01
  -1.000000e+00
  -1.000000e+00
  3.829420e-01
  -1.000000e+00
  4.652502e-03
  
  5.399180e-01
  -1.000000e+00
  -1.000000e+00
  1.443780e+00
  -1.000000e+00
  1.512698e-04
  
  5.399180e-01
  -1.000000e+00
  -1.000000e+00
  5.714131e+00
  -1.000000e+00
  2.175886e-07
  
  5.399180e-01
  -1.000000e+00
  -1.000000e+00
  2.274454e+01
  -1.000000e+00
  1.785035e-13
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  7.618840e-01
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  2.880562e+00
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  1.140527e+01
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  4.528512e+01
  -1.000000e+00
  -1.000000e+00
  
  5.389180e-01
  -1.000000e+00
  -1.000000e+00
  3.819420e-01
  -1.000000e+00
  3.455232e-04
  
  5.389180e-01
  -1.000000e+00
  -1.000000e+00
  1.444780e+00
  -1.000000e+00
  1.429985e-06
  
  5.389180e-01
  -1.000000e+00
  -1.000000e+00
  5.714131e+00
  -1.000000e+00
  2.852419e-11
  
  5.389180e-01
  -1.000000e+00
  -1.000000e+00
  2.274054e+01
  -1.000000e+00
  3.223444e-16
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  7.618840e-01
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  2.887561e+00
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  1.138027e+01
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  4.528711e+01
  -1.000000e+00
  -1.000000e+00
  
  5.389190e-01
  -1.000000e+00
  -1.000000e+00
  3.819420e-01
  -1.000000e+00
  2.010003e-05
  
  5.389190e-01
  -1.000000e+00
  -1.000000e+00
  1.443781e+00
  -1.000000e+00
  7.290371e-09
  
  5.389190e-01
  -1.000000e+00
  -1.000000e+00
  5.723130e+00
  -1.000000e+00
  1.110297e-15
  
  5.389190e-01
  -1.000000e+00
  -1.000000e+00
  2.276654e+01
  -1.000000e+00
  1.378917e-16
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  7.628840e-01
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  2.880562e+00
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  1.137827e+01
  -1.000000e+00
  -1.000000e+00
  
  -1.000000e+00
  -1.000000e+00
  -1.000000e+00
  4.529611e+01
  -1.000000e+00
  -1.000000e+00
  
  0
  0
  2
  1
  0.700000
  0.600000
  4
  16
  32
  64
  128
  1
  1000
  1000
  1
  0
  1
  5.379190e-01
  -1.000000e+00
  3.699400e-02
  -1.000000e+00
  2.455525e-04
  -1.000000e+00
  
  5.379190e-01
  -1.000000e+00
  1.049840e-01
  -1.000000e+00
  1.328986e-06
  -1.000000e+00
  
  5.379190e-01
  -1.000000e+00
  3.389480e-01
  -1.000000e+00
  1.611594e-11
  -1.000000e+00
  
  5.379190e-01
  -1.000000e+00
  1.707741e+00
  -1.000000e+00
  4.206773e-16
  -1.000000e+00
  
  5.369180e-01
  -1.000000e+00
  3.799400e-02
  -1.000000e+00
  1.530038e-05
  -1.000000e+00
  
  5.369180e-01
  -1.000000e+00
  1.039840e-01
  -1.000000e+00
  6.869470e-09
  -1.000000e+00
  
  5.369180e-01
  -1.000000e+00
  3.399490e-01
  -1.000000e+00
  5.766784e-16
  -1.000000e+00
  
  5.369180e-01
  -1.000000e+00
  1.708740e+00
  -1.000000e+00
  1.893048e-16
  -1.000000e+00

  To each combination of kernel function, cut-off degree and node set
  corresponds a single run of the summation algorithm and therefore a set of
  six result values group together. These are
  - the time needed for direct evaluation of the sums (1),
  - the time needed for direct evaluation of the sums (1) with the values of
    the kernel functions precomputed,
  - the time needed by the fast summation algorithm using the direct NDSFT
    algorithm,
  - the time needed by the fast summation algorithm using the NFSFT algorithm,
  - the error E_infty for the fast summation algorithm using the direct NDSFT
    algorithm,
  - the error E_infty for the fast summation algorithm using the NFSFT
    algorithm.

  Here the error E_infty is defined as ||f - f_M||_infty / ||b||_1 with the
  infinity norm ||.||_infty, the one norm ||.||_1, the vector f of function
  values computed by direct evaluation of the sums in (1), f_M the vector
  computed by the fast summation algorithm, using either the direct NDSFT or
  the NFSFT algorithm, and the vector b containing the coefficients b_l from
  (1).
  Depending on the parameter combination some of these (positive) values might
  be undefined which is indicated by a value of -1.0.
  The blocks of result values for a single run are grouped for each testcase
  first by the kernel parameters, second by the node set and third by the
  cut-off bandwidth ordered as in the input.



  References:

  [1] Keiner, J., Kunis, S. and Potts, D., Fast summation of radial functions 
      on the sphere, Computing, to appear, 2005

  [2] Kunis, S. and Potts, D., Fast spherical Fourier algorithms, J. Comput.
      Appl. Math. 161, 75-98, 2003

