// !$*UTF8*$!
{
	08FB7793FE84155DC02AAC07 = {
		activeBuildStyle = 014CEA460018CE2711CA2923;
		activeExecutable = 4EB20A1E07D4B30C00FD1AB8;
		activeTarget = 8DD76F620486A84900D96B5E;
		addToTargets = (
		);
		breakpoints = (
		);
		codeSenseManager = 4E25C4AC070DDADD0005BF02;
		executables = (
			4EB20A1E07D4B30C00FD1AB8,
			4E6E40E9082CB6C600642FF0,
		);
		perUserDictionary = {
			PBXConfiguration.PBXFileTableDataSource3.PBXBookmarksDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXBookmarksDataSource_NameID;
				PBXFileTableDataSourceColumnWidthsKey = (
					245.2085,
					228.5991,
					255.5835,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXBookmarksDataSource_LocationID,
					PBXBookmarksDataSource_NameID,
					PBXBookmarksDataSource_CommentsID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXErrorsWarningsDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXErrorsWarningsDataSource_LocationID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					577.8799,
					311.2085,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXErrorsWarningsDataSource_TypeID,
					PBXErrorsWarningsDataSource_MessageID,
					PBXErrorsWarningsDataSource_LocationID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXExecutablesDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = 1;
				PBXFileTableDataSourceColumnSortingKey = PBXExecutablesDataSource_NameID;
				PBXFileTableDataSourceColumnWidthsKey = (
					22,
					596.7974,
					309.5835,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXExecutablesDataSource_ActiveFlagID,
					PBXExecutablesDataSource_NameID,
					PBXExecutablesDataSource_CommentsID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXFileTableDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					652,
					20,
					116,
					43,
					43,
					20,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
					PBXFileDataSource_Target_ColumnID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXFindDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFindDataSource_LocationID;
				PBXFileTableDataSourceColumnWidthsKey = (
					367.2974,
					370.2085,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFindDataSource_MessageID,
					PBXFindDataSource_LocationID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.PBXSymbolsDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXSymbolsDataSource_SymbolNameID;
				PBXFileTableDataSourceColumnWidthsKey = (
					16,
					279.8008,
					309.0356,
					286.2085,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXSymbolsDataSource_SymbolTypeIconID,
					PBXSymbolsDataSource_SymbolNameID,
					PBXSymbolsDataSource_SymbolTypeID,
					PBXSymbolsDataSource_ReferenceNameID,
				);
			};
			PBXConfiguration.PBXFileTableDataSource3.XCSCMDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					20,
					671,
					20,
					104,
					43,
					43,
					20,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_SCM_ColumnID,
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
					PBXFileDataSource_Target_ColumnID,
				);
			};
			PBXConfiguration.PBXTargetDataSource.PBXTargetDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = 1;
				PBXFileTableDataSourceColumnSortingKey = PBXTargetDataSource_PrimaryAttribute;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					550,
					118,
					20,
					118,
					43,
					43,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXTargetDataSource_PrimaryAttribute,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
				);
			};
			PBXPerProjectTemplateStateSaveDate = 143716558;
			PBXPrepackagedSmartGroups_v2 = (
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					activationKey = OldTargetSmartGroup;
					clz = PBXTargetSmartGroup;
					description = "Displays all targets of the project.";
					globalID = 1C37FABC04509CD000000102;
					name = Targets;
					preferences = {
						image = Targets;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXTargetSmartGroup2;
					description = "Displays all targets of the project as well as nested build phases.";
					globalID = 1C37FBAC04509CD000000102;
					name = Targets;
					preferences = {
						image = Targets;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXExecutablesSmartGroup;
					description = "Displays all executables of the project.";
					globalID = 1C37FAAC04509CD000000102;
					name = Executables;
					preferences = {
						image = Executable;
					};
				},
				{
					" PBXTransientLocationAtTop " = bottom;
					absolutePathToBundle = "";
					clz = PBXErrorsWarningsSmartGroup;
					description = "Displays files with errors or warnings.";
					globalID = 1C08E77C0454961000C914BD;
					name = "Errors and Warnings";
					preferences = {
						fnmatch = "";
						image = WarningsErrors;
						recursive = 1;
						regex = "";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "Filters items in a given group (potentially recursively) based on matching the name with the regular expression of the filter.";
					globalID = 1CC0EA4004350EF90044410B;
					name = "Implementation Files";
					preferences = {
						canSave = 1;
						fnmatch = "";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "?*\\.[mcMC]";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "This group displays Interface Builder NIB Files.";
					globalID = 1CC0EA4004350EF90041110B;
					name = "NIB Files";
					preferences = {
						canSave = 1;
						fnmatch = "*.nib";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = no;
					absolutePathToBundle = "";
					clz = PBXFindSmartGroup;
					description = "Displays Find Results.";
					globalID = 1C37FABC05509CD000000102;
					name = "Find Results";
					preferences = {
						image = spyglass;
					};
				},
				{
					PBXTransientLocationAtTop = no;
					absolutePathToBundle = "";
					clz = PBXBookmarksSmartGroup;
					description = "Displays Project Bookmarks.";
					globalID = 1C37FABC05539CD112110102;
					name = Bookmarks;
					preferences = {
						image = Bookmarks;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = XCSCMSmartGroup;
					description = "Displays files with interesting SCM status.";
					globalID = E2644B35053B69B200211256;
					name = SCM;
					preferences = {
						image = PBXRepository;
						isLeaf = 0;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXSymbolsSmartGroup;
					description = "Displays all symbols for the project.";
					globalID = 1C37FABC04509CD000100104;
					name = "Project Symbols";
					preferences = {
						image = ProjectSymbols;
						isLeaf = 1;
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "Filters items in a given group (potentially recursively) based on matching the name with the regular expression of the filter.";
					globalID = PBXTemplateMarker;
					name = "Simple Filter SmartGroup";
					preferences = {
						canSave = 1;
						fnmatch = "*.nib";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					absolutePathToBundle = "";
					clz = PBXFilenameSmartGroup;
					description = "Filters items in a given group (potentially recursively) based on matching the name with the regular expression of the filter.";
					globalID = PBXTemplateMarker;
					name = "Simple Regular Expression SmartGroup";
					preferences = {
						canSave = 1;
						fnmatch = "";
						image = SmartFolder;
						isLeaf = 0;
						recursive = 1;
						regex = "?*\\.[mcMC]";
						root = "<PROJECT>";
					};
				},
				{
					PBXTransientLocationAtTop = bottom;
					clz = XDDesignSmartGroup;
					description = "Displays Xdesign models";
					globalID = 2E4A936305E6979E00701470;
					name = Design;
					preferences = {
						image = Design;
						isLeaf = 0;
					};
				},
			);
			PBXWorkspaceContents = (
				{
					PBXProjectWorkspaceModule_StateKey_Rev39 = {
						PBXProjectWorkspaceModule_DataSourceSelectionKey_Rev6 = {
							BoundsStr = "{{0, 0}, {1083, 762}}";
							Rows = (
								0,
							);
							VisibleRectStr = "{{0, 0}, {1083, 762}}";
						};
						PBXProjectWorkspaceModule_EditorOpen = false;
						PBXProjectWorkspaceModule_EmbeddedNavigatorGroup = {
							PBXSplitModuleInNavigatorKey = {
								SplitCount = 1;
							};
						};
						PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
							PBXProjectWorkspaceModule_SGTM_Geometry = {
								_collapsingFrameDimension = 0;
								_indexOfCollapsedView = 0;
								_percentageOfCollapsedView = 0;
								sizes = (
									"{{0, 0}, {182, 779}}",
									"{{182, 0}, {1098, 779}}",
								);
							};
						};
						PBXProjectWorkspaceModule_OldDetailFrame = "{{0, 0}, {1098, 779}}";
						PBXProjectWorkspaceModule_OldEditorFrame = "{{0, 0}, {750, 480}}";
						PBXProjectWorkspaceModule_OldSuperviewFrame = "{{182, 0}, {1098, 779}}";
						PBXProjectWorkspaceModule_SGTM = {
							PBXBottomSmartGroupGIDs = (
								1C37FBAC04509CD000000102,
								1C37FAAC04509CD000000102,
								1C08E77C0454961000C914BD,
								1CC0EA4004350EF90044410B,
								1CC0EA4004350EF90041110B,
								1C37FABC05509CD000000102,
								1C37FABC05539CD112110102,
								E2644B35053B69B200211256,
								1C37FABC04509CD000100104,
							);
							PBXSmartGroupTreeModuleColumnData = {
								PBXSmartGroupTreeModuleColumnWidthsKey = (
									165,
								);
								PBXSmartGroupTreeModuleColumnsKey_v4 = (
									MainColumn,
								);
							};
							PBXSmartGroupTreeModuleOutlineStateKey_v7 = {
								PBXSmartGroupTreeModuleOutlineStateExpansionKey = (
									1C37FBAC04509CD000000102,
									4E45F9A9070DDB1D001B6525,
									4E45F9CE070DDDB2001B6525,
									1C37FAAC04509CD000000102,
								);
								PBXSmartGroupTreeModuleOutlineStateSelectionKey = (
									(
										10,
										9,
									),
								);
								PBXSmartGroupTreeModuleOutlineStateVisibleRectKey = "{{0, 0}, {165, 761}}";
							};
							PBXTopSmartGroupGIDs = (
							);
						};
					};
				},
			);
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXBuildResultsModule" = {
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXDebugCLIModule" = {
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXNavigatorGroup" = {
				PBXSplitModuleInNavigatorKey = {
					SplitCount = 1;
				};
			};
			"PBXWorkspaceContents:PBXConfiguration.PBXModule.PBXProjectWorkspaceModule" = {
				PBXProjectWorkspaceModule_StateKey_Rev39 = {
					PBXProjectWorkspaceModule_DataSourceSelectionKey_Rev6 = {
						BoundsStr = "{{0, 0}, {1083, 762}}";
						Rows = (
							0,
						);
						VisibleRectStr = "{{0, 0}, {1083, 762}}";
					};
					PBXProjectWorkspaceModule_EditorOpen = false;
					PBXProjectWorkspaceModule_EmbeddedNavigatorGroup = {
						PBXSplitModuleInNavigatorKey = {
							SplitCount = 1;
						};
					};
					PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
						PBXProjectWorkspaceModule_SGTM_Geometry = {
							_collapsingFrameDimension = 0;
							_indexOfCollapsedView = 0;
							_percentageOfCollapsedView = 0;
							sizes = (
								"{{0, 0}, {182, 779}}",
								"{{182, 0}, {1098, 779}}",
							);
						};
					};
					PBXProjectWorkspaceModule_OldDetailFrame = "{{0, 0}, {1098, 779}}";
					PBXProjectWorkspaceModule_OldEditorFrame = "{{0, 0}, {750, 480}}";
					PBXProjectWorkspaceModule_OldSuperviewFrame = "{{182, 0}, {1098, 779}}";
					PBXProjectWorkspaceModule_SGTM = {
						PBXBottomSmartGroupGIDs = (
							1C37FBAC04509CD000000102,
							1C37FAAC04509CD000000102,
							1C08E77C0454961000C914BD,
							1CC0EA4004350EF90044410B,
							1CC0EA4004350EF90041110B,
							1C37FABC05509CD000000102,
							1C37FABC05539CD112110102,
							E2644B35053B69B200211256,
							1C37FABC04509CD000100104,
						);
						PBXSmartGroupTreeModuleColumnData = {
							PBXSmartGroupTreeModuleColumnWidthsKey = (
								165,
							);
							PBXSmartGroupTreeModuleColumnsKey_v4 = (
								MainColumn,
							);
						};
						PBXSmartGroupTreeModuleOutlineStateKey_v7 = {
							PBXSmartGroupTreeModuleOutlineStateExpansionKey = (
							);
							PBXSmartGroupTreeModuleOutlineStateSelectionKey = (
								(
									0,
								),
							);
							PBXSmartGroupTreeModuleOutlineStateVisibleRectKey = "{{0, 0}, {165, 761}}";
						};
						PBXTopSmartGroupGIDs = (
						);
					};
				};
			};
			PBXWorkspaceGeometries = (
				{
					Frame = "{{0, 0}, {1280, 779}}";
					PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
					};
					RubberWindowFrame = "0 117 1280 821 0 0 1280 938 ";
				},
			);
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXBuildResultsModule" = {
				Frame = "{{0, 0}, {480, 217}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "400 560 480 238 0 0 1280 938 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXDebugCLIModule" = {
				Frame = "{{0, 0}, {400, 201}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "50 910 400 222 0 0 1280 938 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXNavigatorGroup" = {
				Frame = "{{0, 0}, {750, 481}}";
				PBXModuleWindowStatusBarHidden = YES;
				RubberWindowFrame = "38 410 750 502 0 0 1280 938 ";
			};
			"PBXWorkspaceGeometries:PBXConfiguration.PBXModule.PBXProjectWorkspaceModule" = {
				Frame = "{{0, 0}, {1280, 779}}";
				PBXProjectWorkspaceModule_GeometryKey_Rev15 = {
				};
				RubberWindowFrame = "0 117 1280 821 0 0 1280 938 ";
			};
			PBXWorkspaceStateSaveDate = 143716558;
		};
		perUserProjectItems = {
			4E00A414086F469A0062012D = 4E00A414086F469A0062012D;
			4E29328C082E50BD004AD73C = 4E29328C082E50BD004AD73C;
			4E29328E082E50BD004AD73C = 4E29328E082E50BD004AD73C;
			4E2932B3082E5ABD004AD73C = 4E2932B3082E5ABD004AD73C;
			4E29332B082E67D9004AD73C = 4E29332B082E67D9004AD73C;
			4E294DA908577C8700F546C3 = 4E294DA908577C8700F546C3;
			4E5471090832A94F00CA0375 = 4E5471090832A94F00CA0375;
			4E6A5CA0082EA09E00ED6FD8 = 4E6A5CA0082EA09E00ED6FD8;
			4E6A5CA3082EA09E00ED6FD8 = 4E6A5CA3082EA09E00ED6FD8;
			4E6A5CA8082EA12700ED6FD8 = 4E6A5CA8082EA12700ED6FD8;
			4E6A5CBD082EA20000ED6FD8 = 4E6A5CBD082EA20000ED6FD8;
			4E6A5CC3082EA20000ED6FD8 = 4E6A5CC3082EA20000ED6FD8;
			4E6C0277085316E90095AA39 = 4E6C0277085316E90095AA39;
			4E6C0285085318950095AA39 = 4E6C0285085318950095AA39;
			4E6C5EC8088E96680051B166 = 4E6C5EC8088E96680051B166;
			4E6C5ECE088E96C10051B166 = 4E6C5ECE088E96C10051B166;
			4E6E72130855C89400D77920 = 4E6E72130855C89400D77920;
			4E7021F30886930C00CBA928 = 4E7021F30886930C00CBA928;
			4E7021F40886930C00CBA928 = 4E7021F40886930C00CBA928;
			4E7021F70886930C00CBA928 = 4E7021F70886930C00CBA928;
			4E7021F80886930C00CBA928 = 4E7021F80886930C00CBA928;
			4E7022200887F8C700CBA928 = 4E7022200887F8C700CBA928;
			4E7022210887F8C700CBA928 = 4E7022210887F8C700CBA928;
			4E720984084F7DAE007F8CEA = 4E720984084F7DAE007F8CEA;
			4E751588082C0D65002018A8 = 4E751588082C0D65002018A8;
			4E757C62087FDC0C0027229F = 4E757C62087FDC0C0027229F;
			4E7692190852D4160088C885 = 4E7692190852D4160088C885;
			4E7848BA08903A1600842C4C = 4E7848BA08903A1600842C4C;
			4E8A26AA0838C11700216481 = 4E8A26AA0838C11700216481;
			4E8A27670838E2CF00216481 = 4E8A27670838E2CF00216481;
			4E8E5792083E4CA60061697E = 4E8E5792083E4CA60061697E;
			4E8F457B0850CE760098CEFF = 4E8F457B0850CE760098CEFF;
			4E8F45840850CE760098CEFF = 4E8F45840850CE760098CEFF;
			4E8FDDA5088A73E10098D700 = 4E8FDDA5088A73E10098D700;
			4E8FDDA6088A73E10098D700 = 4E8FDDA6088A73E10098D700;
			4E8FDDA7088A73E10098D700 = 4E8FDDA7088A73E10098D700;
			4E8FDDA8088A73E10098D700 = 4E8FDDA8088A73E10098D700;
			4E8FDDB3088A73E10098D700 = 4E8FDDB3088A73E10098D700;
			4E8FDDD8088AC08F0098D700 = 4E8FDDD8088AC08F0098D700;
			4E8FDDEC088AC0FA0098D700 = 4E8FDDEC088AC0FA0098D700;
			4E8FDDF0088AC2F80098D700 = 4E8FDDF0088AC2F80098D700;
			4E8FDDF1088AC2F80098D700 = 4E8FDDF1088AC2F80098D700;
			4E8FDDF2088AC2F80098D700 = 4E8FDDF2088AC2F80098D700;
			4E8FDDF5088AC2F80098D700 = 4E8FDDF5088AC2F80098D700;
			4E8FDDF7088AC2F80098D700 = 4E8FDDF7088AC2F80098D700;
			4E8FDDFC088AC2F80098D700 = 4E8FDDFC088AC2F80098D700;
			4E8FDE04088AC3610098D700 = 4E8FDE04088AC3610098D700;
			4E8FDE12088AC7020098D700 = 4E8FDE12088AC7020098D700;
			4E8FDE19088AF3D40098D700 = 4E8FDE19088AF3D40098D700;
			4E8FDE1B088AF3D40098D700 = 4E8FDE1B088AF3D40098D700;
			4E8FDE1F088AF3D40098D700 = 4E8FDE1F088AF3D40098D700;
			4E98AAC2084A23820002D4FC = 4E98AAC2084A23820002D4FC;
			4E9F7CAC0851DA3100952ECD = 4E9F7CAC0851DA3100952ECD;
			4EA42B57087E6423004F81E3 = 4EA42B57087E6423004F81E3;
			4EAB55900879C3B700919EC9 = 4EAB55900879C3B700919EC9;
			4EAD6954083BD14300C61F13 = 4EAD6954083BD14300C61F13;
			4EAD6969083BD39C00C61F13 = 4EAD6969083BD39C00C61F13;
			4EAD696A083BD39C00C61F13 = 4EAD696A083BD39C00C61F13;
			4EB6E510083143AE003AAA48 = 4EB6E510083143AE003AAA48;
			4ECF7CD3087BC75A00F4A43E = 4ECF7CD3087BC75A00F4A43E;
			4ECF7CD4087BC75A00F4A43E = 4ECF7CD4087BC75A00F4A43E;
			4ECF7CD5087BC75A00F4A43E = 4ECF7CD5087BC75A00F4A43E;
			4ECF7CD7087BC75A00F4A43E = 4ECF7CD7087BC75A00F4A43E;
			4ECF7CDC087BC75A00F4A43E = 4ECF7CDC087BC75A00F4A43E;
			4ECF7CDD087BC75A00F4A43E = 4ECF7CDD087BC75A00F4A43E;
			4ECF7CDF087BC75A00F4A43E = 4ECF7CDF087BC75A00F4A43E;
			4ECF7CE0087BC75A00F4A43E = 4ECF7CE0087BC75A00F4A43E;
			4ED469F80890F0D400F4E929 = 4ED469F80890F0D400F4E929;
			4ED469F90890F0D400F4E929 = 4ED469F90890F0D400F4E929;
			4ED469FD0890F17700F4E929 = 4ED469FD0890F17700F4E929;
			4ED469FE0890F17700F4E929 = 4ED469FE0890F17700F4E929;
			4ED469FF0890F17700F4E929 = 4ED469FF0890F17700F4E929;
			4ED46A000890F17700F4E929 = 4ED46A000890F17700F4E929;
			4ED46A010890F17700F4E929 = 4ED46A010890F17700F4E929;
			4ED46A020890F17700F4E929 = 4ED46A020890F17700F4E929;
			4ED46A030890F17700F4E929 = 4ED46A030890F17700F4E929;
			4ED46A060890F62700F4E929 = 4ED46A060890F62700F4E929;
			4ED46A070890F70500F4E929 = 4ED46A070890F70500F4E929;
			4ED46A080891060E00F4E929 = 4ED46A080891060E00F4E929;
			4ED46A090891084F00F4E929 = 4ED46A090891084F00F4E929;
			4ED46A0A089109C900F4E929 = 4ED46A0A089109C900F4E929;
			4ED46A0B089109C900F4E929 = 4ED46A0B089109C900F4E929;
			4ED46A0C089109C900F4E929 = 4ED46A0C089109C900F4E929;
			4ED46A0D089109C900F4E929 = 4ED46A0D089109C900F4E929;
			4ED46A0E089109C900F4E929 = 4ED46A0E089109C900F4E929;
			4ED46A0F08910A5900F4E929 = 4ED46A0F08910A5900F4E929;
			4ED46A1008910A5900F4E929 = 4ED46A1008910A5900F4E929;
			4ED46A1108910A5900F4E929 = 4ED46A1108910A5900F4E929;
			4ED46A1208910A5900F4E929 = 4ED46A1208910A5900F4E929;
			4ED46A1308910A5900F4E929 = 4ED46A1308910A5900F4E929;
			4ED46A1408910A5900F4E929 = 4ED46A1408910A5900F4E929;
			4ED46A1508910C6700F4E929 = 4ED46A1508910C6700F4E929;
			4ED46A1608910C6700F4E929 = 4ED46A1608910C6700F4E929;
			4ED46A1708910C6700F4E929 = 4ED46A1708910C6700F4E929;
			4ED46A1808910C6700F4E929 = 4ED46A1808910C6700F4E929;
			4ED46A1908910C6700F4E929 = 4ED46A1908910C6700F4E929;
			4ED46A1A08910EB500F4E929 = 4ED46A1A08910EB500F4E929;
			4ED46A1B08910ECA00F4E929 = 4ED46A1B08910ECA00F4E929;
			4ED46A1C08910EDD00F4E929 = 4ED46A1C08910EDD00F4E929;
			4ED46A1D08910F0000F4E929 = 4ED46A1D08910F0000F4E929;
			4ED46A1E08910F7400F4E929 = 4ED46A1E08910F7400F4E929;
			4ED46A2008910F7400F4E929 = 4ED46A2008910F7400F4E929;
			4ED46A2108910F7400F4E929 = 4ED46A2108910F7400F4E929;
			4ED46A2308910F7400F4E929 = 4ED46A2308910F7400F4E929;
			4EDEC4EB07CE349A00514E5A = 4EDEC4EB07CE349A00514E5A;
			4EE0558D086DA00D003A47E5 = 4EE0558D086DA00D003A47E5;
			4EE0559B086DA10C003A47E5 = 4EE0559B086DA10C003A47E5;
			4EE055AD086DA4D6003A47E5 = 4EE055AD086DA4D6003A47E5;
			4EE055E4086DA894003A47E5 = 4EE055E4086DA894003A47E5;
			4EE055EA086DA935003A47E5 = 4EE055EA086DA935003A47E5;
			4EE055EB086DA935003A47E5 = 4EE055EB086DA935003A47E5;
			4EE056E6086DE4EE003A47E5 = 4EE056E6086DE4EE003A47E5;
			4EE659D4087F92A000926C77 = 4EE659D4087F92A000926C77;
			4EE65A2A087FA0F000926C77 = 4EE65A2A087FA0F000926C77;
			4EE9EBAF08786E2B00880508 = 4EE9EBAF08786E2B00880508;
			4EE9EBB908786EE000880508 = 4EE9EBB908786EE000880508;
			4EE9EBD20878768200880508 = 4EE9EBD20878768200880508;
			4EE9EBD508787B6200880508 = 4EE9EBD508787B6200880508;
		};
		sourceControlManager = 4E25C4AB070DDADD0005BF02;
		userBuildSettings = {
		};
	};
	4E00A414086F469A0062012D = {
		fRef = 4E294D5008575D3600F546C3;
		isa = PBXTextBookmark;
		name = "healpix.c: 190";
		rLen = 0;
		rLoc = 4522;
		rType = 0;
		vrLen = 609;
		vrLoc = 4457;
	};
	4E02C48E082F816D00EC0863 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 4063}}";
			sepNavSelRange = "{1326, 0}";
			sepNavVisRect = "{{0, 618}, {910, 470}}";
		};
	};
	4E0887C0071585CD005706CD = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {734, 3679}}";
			sepNavSelRange = "{735, 3}";
			sepNavVisRect = "{{0, 0}, {734, 359}}";
		};
	};
	4E0887C1071585CD005706CD = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {943, 437}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {943, 437}}";
		};
	};
	4E13CA0B07EB1770003D3B6C = {
		isa = PBXFileReference;
		lastKnownFileType = sourcecode.c.h;
		name = fftw3.h;
		path = /sw/include/fftw3.h;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4E23D9390854D1E300CC656A = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {734, 3135}}";
			sepNavSelRange = "{3391, 0}";
			sepNavVisRect = "{{0, 2181}, {734, 295}}";
		};
	};
	4E25C4AB070DDADD0005BF02 = {
		fallbackIsa = XCSourceControlManager;
		isSCMEnabled = 0;
		isa = PBXSourceControlManager;
		scmConfiguration = {
		};
		scmType = scm.subversion;
	};
	4E25C4AC070DDADD0005BF02 = {
		indexTemplatePath = "";
		isa = PBXCodeSenseManager;
		usesDefaults = 1;
		wantsCodeCompletion = 1;
		wantsCodeCompletionAutoSuggestions = 0;
		wantsCodeCompletionCaseSensitivity = 1;
		wantsCodeCompletionListAlways = 1;
		wantsCodeCompletionOnlyMatchingItems = 1;
		wantsCodeCompletionParametersIncluded = 1;
		wantsCodeCompletionPlaceholdersInserted = 1;
		wantsCodeCompletionTabCompletes = 1;
		wantsIndex = 1;
	};
	4E293281082E501F004AD73C = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 470}}";
			sepNavSelRange = "{307, 0}";
			sepNavVisRect = "{{0, 0}, {910, 470}}";
		};
	};
	4E293282082E501F004AD73C = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 10687}}";
			sepNavSelRange = "{14850, 0}";
			sepNavVisRect = "{{0, 0}, {910, 470}}";
		};
	};
	4E29328C082E50BD004AD73C = {
		fRef = 4E6E40C2082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "/** inverse nfft \n * -----------------------------------------------------------------------------\n * -----------------------------------------------------------------------------\n */\nvoid infft_init_specific(infft_plan *this_iplan, nfft_plan *direct_plan,\n\t\t\t int infft_flags)\n{\n  this_iplan->direct_plan = direct_plan;\n  this_iplan->infft_flags = infft_flags;\n  \n  this_iplan->given_f = (fftw_complex*)\n    fftw_malloc(this_iplan->direct_plan->M*sizeof(fftw_complex));\n\n  this_iplan->r_iter = (fftw_complex*)\n    fftw_malloc(this_iplan->direct_plan->M*sizeof(fftw_complex));\n\n  this_iplan->f_hat_iter = (fftw_complex*)\n    fftw_malloc(this_iplan->direct_plan->N_L*sizeof(fftw_complex));\n\n  this_iplan->p_hat_iter = (fftw_complex*)\n    fftw_malloc(this_iplan->direct_plan->N_L*sizeof(fftw_complex));\n\n  if(this_iplan->infft_flags & LANDWEBER)\n    {\n      this_iplan->z_hat_iter = this_iplan->p_hat_iter;\n    }\n\n  if(this_iplan->infft_flags & STEEPEST_DESCENT)\n    {\n      this_iplan->z_hat_iter = this_iplan->p_hat_iter;\n\n      this_iplan->v_iter = (fftw_complex*)\n\tfftw_malloc(this_iplan->direct_plan->M*sizeof(fftw_complex));\n    }\n\n  if(this_iplan->infft_flags & CGNR_E)\n    {\n      this_iplan->z_hat_iter = (fftw_complex*)\n\tfftw_malloc(this_iplan->direct_plan->N_L*sizeof(fftw_complex));\n\n      this_iplan->v_iter = (fftw_complex*)\n\tfftw_malloc(this_iplan->direct_plan->M*sizeof(fftw_complex));\n    }\n\n  if(this_iplan->infft_flags & CGNE_R)\n    {\n      this_iplan->z_hat_iter = this_iplan->p_hat_iter;\n    }\n\n  if(this_iplan->infft_flags & ITERATE_2nd)\n    this_iplan->f_hat_iter_2nd = (fftw_complex*) \n      fftw_malloc(this_iplan->direct_plan->N_L*sizeof(fftw_complex));\n\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    this_iplan->w = \n      (double*) fftw_malloc(this_iplan->direct_plan->M*sizeof(double));\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    this_iplan->w_hat = \n      (double*) fftw_malloc(this_iplan->direct_plan->N_L*sizeof(double));\n}\n\nvoid infft_init(infft_plan *this_iplan, nfft_plan *direct_plan)\n{\n  infft_init_specific(this_iplan, direct_plan, CGNR_E);\n}\n\nvoid infft_before_loop_help(infft_plan *this_iplan)\n{\n  /** step 2\n   *  overwrites this_iplan->direct_plan->f_hat \n   *  overwrites this_iplan->r_iter\n   */\n  copyc(this_iplan->direct_plan->f_hat, this_iplan->f_hat_iter,\n\tthis_iplan->direct_plan->N_L);\n  \n  SWAPC(this_iplan->r_iter, this_iplan->direct_plan->f);\n  nfft_trafo(this_iplan->direct_plan);\n  SWAPC(this_iplan->r_iter, this_iplan->direct_plan->f);\n\n  updatec_axpy(this_iplan->r_iter, -1.0, this_iplan->given_f,\n\t       this_iplan->direct_plan->M);\n\n  if((!(this_iplan->infft_flags & LANDWEBER)) ||\n     (this_iplan->infft_flags & NORMS_FOR_LANDWEBER))\n    {\n      if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n\tthis_iplan->dot_r_iter =\n\t  dotproductc_w(this_iplan->r_iter, this_iplan->w,\n\t\t\tthis_iplan->direct_plan->M);\n      else\n\tthis_iplan->dot_r_iter =\n\t  dotproductc(this_iplan->r_iter, this_iplan->direct_plan->M);\n    }\n  \n  /** step 3\n   *  overwrites this_iplan->direct_plan->f\n   *  overwrites this_iplan->z_hat_iter resp. this_iplan->z_hat_iter\n   */ \n\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    copyc_w(this_iplan->direct_plan->f, this_iplan->w, this_iplan->r_iter,\n\t    this_iplan->direct_plan->M);\n  else\n    copyc(this_iplan->direct_plan->f, this_iplan->r_iter,\n\t  this_iplan->direct_plan->M);\n  \n  SWAPC(this_iplan->z_hat_iter, this_iplan->direct_plan->f_hat);\n  nfft_adjoint(this_iplan->direct_plan);\n  SWAPC(this_iplan->z_hat_iter, this_iplan->direct_plan->f_hat);\n  \n  if((!(this_iplan->infft_flags & LANDWEBER)) ||\n     (this_iplan->infft_flags & NORMS_FOR_LANDWEBER))\n    {\n      if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n\tthis_iplan->dot_z_hat_iter = \n\t  dotproductc_w(this_iplan->z_hat_iter, this_iplan->w_hat,\n\t\t\tthis_iplan->direct_plan->N_L);\n      else\n\tthis_iplan->dot_z_hat_iter =\n\t  dotproductc(this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n    }\n\n  if(this_iplan->infft_flags & CGNE_R)\n    this_iplan->dot_p_hat_iter = this_iplan->dot_z_hat_iter;\n\n} /* void infft_before_loop_help */\n\nvoid infft_before_loop(infft_plan *this_iplan)\n{\n  infft_before_loop_help(this_iplan);\n\n  if(this_iplan->infft_flags & CGNR_E)\n    {\n      /** step 4-6\n       *  overwrites this_iplan->f_hat_iter_2nd\n       */\n      if(this_iplan->infft_flags & ITERATE_2nd)\n\tcopyc(this_iplan->f_hat_iter_2nd, this_iplan->f_hat_iter,\n\t      this_iplan->direct_plan->N_L);\n     \n      /** step 7\n       *  overwrites this_iplan->p_hat_iter\n       */\n      copyc(this_iplan->p_hat_iter, this_iplan->z_hat_iter,\n\t    this_iplan->direct_plan->N_L);\n    }\n\n  if(this_iplan->infft_flags & CGNE_R)\n    {\n      /** step 4-7\n       *  overwrites this_iplan->f_hat_iter_2nd\n       */\n      if(this_iplan->infft_flags & ITERATE_2nd)\n\t{\n\t  this_iplan->gamma_iter=1.0;\n\t  copyc(this_iplan->f_hat_iter_2nd, this_iplan->f_hat_iter,\n\t\tthis_iplan->direct_plan->N_L);\n\t}\n    }\n} /* void infft_before_loop */\n\nvoid infft_loop_one_step_landweber(infft_plan *this_iplan)\n{\n  /** step 5\n   *  updates this_iplan->f_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    updatec_xpawy(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\t  this_iplan->w_hat, this_iplan->z_hat_iter,\n\t\t  this_iplan->direct_plan->N_L);\n  else\n    updatec_xpay(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\tthis_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n  \n  /** step 6\n   *  original residual, not the updated residual,\n   *  overwrites this_iplan->r_iter\n   *  overwrites this_iplan->direct_plan->f_hat \n   */\n  copyc(this_iplan->direct_plan->f_hat, this_iplan->f_hat_iter,\n\tthis_iplan->direct_plan->N_L);\n\n  SWAPC(this_iplan->r_iter,this_iplan->direct_plan->f);\n  nfft_trafo(this_iplan->direct_plan);\n  SWAPC(this_iplan->r_iter,this_iplan->direct_plan->f);\n  \n  updatec_axpy(this_iplan->r_iter, -1.0, this_iplan->given_f, \n\t       this_iplan->direct_plan->M);\n\n  if(this_iplan->infft_flags & NORMS_FOR_LANDWEBER)\n    {\n      if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n\tthis_iplan->dot_r_iter = dotproductc_w(this_iplan->r_iter,this_iplan->w,\n\t\t\t\t\t       this_iplan->direct_plan->M);\n      else\n\tthis_iplan->dot_r_iter =\n\t  dotproductc(this_iplan->r_iter, this_iplan->direct_plan->M);\n    }\n\n  /** step 7\n   *  overwrites this_iplan->direct_plan->f \n   *  overwrites this_iplan->z_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    copyc_w(this_iplan->direct_plan->f, this_iplan->w,\n\t    this_iplan->r_iter, this_iplan->direct_plan->M);\n  else\n    copyc(this_iplan->direct_plan->f, this_iplan->r_iter,\n\t  this_iplan->direct_plan->M);\n    \n  SWAPC(this_iplan->z_hat_iter,this_iplan->direct_plan->f_hat);\n  nfft_adjoint(this_iplan->direct_plan);\n  SWAPC(this_iplan->z_hat_iter,this_iplan->direct_plan->f_hat);\n\n  if(this_iplan->infft_flags & NORMS_FOR_LANDWEBER)\n    {\n      if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n\tthis_iplan->dot_z_hat_iter = \n\t  dotproductc_w(this_iplan->z_hat_iter, this_iplan->w_hat,\n\t\t\tthis_iplan->direct_plan->N_L);\n      else\n\tthis_iplan->dot_z_hat_iter =\n\t  dotproductc(this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n    }\n} /* void infft_loop_one_step_landweber */\n\nvoid infft_loop_one_step_steepest_descent(infft_plan *this_iplan)\n{\n  /** step 5\n   *  overwrites this_iplan->direct_plan->f_hat \n   *  overwrites this_iplan->v_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    copyc_w(this_iplan->direct_plan->f_hat, this_iplan->w_hat,\n\t    this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n  else\n    copyc(this_iplan->direct_plan->f_hat, this_iplan->z_hat_iter,\n\t  this_iplan->direct_plan->N_L);\n  \n  SWAPC(this_iplan->v_iter,this_iplan->direct_plan->f);\n  nfft_trafo(this_iplan->direct_plan);\n  SWAPC(this_iplan->v_iter,this_iplan->direct_plan->f);\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    this_iplan->dot_v_iter = dotproductc_w(this_iplan->v_iter, this_iplan->w,\n\t\t\t\t\t   this_iplan->direct_plan->M);\n  else\n    this_iplan->dot_v_iter =\n      dotproductc(this_iplan->v_iter, this_iplan->direct_plan->M);\n  \n  /** step 6\n   */\n  this_iplan->alpha_iter =\n    this_iplan->dot_z_hat_iter / this_iplan->dot_v_iter;\n\n  /** step 7\n   *  updates this_iplan->f_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    updatec_xpawy(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\t  this_iplan->w_hat,this_iplan->z_hat_iter,\n\t\t  this_iplan->direct_plan->N_L);\n  else\n    updatec_xpay(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\tthis_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n\n  /** step 8\n   *  updates this_iplan->r_iter\n   */\n  updatec_xpay(this_iplan->r_iter, -this_iplan->alpha_iter, this_iplan->v_iter,\n\t      this_iplan->direct_plan->M);\n\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    this_iplan->dot_r_iter = dotproductc_w(this_iplan->r_iter, this_iplan->w,\n\t\t\t\t\t   this_iplan->direct_plan->M);\n  else\n    this_iplan->dot_r_iter =\n      dotproductc(this_iplan->r_iter, this_iplan->direct_plan->M);\n\n  /** step 9\n   *  overwrites this_iplan->direct_plan->f\n   *  overwrites this_iplan->z_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    copyc_w(this_iplan->direct_plan->f, this_iplan->w, this_iplan->r_iter,\n\t    this_iplan->direct_plan->M);\n  else\n    copyc(this_iplan->direct_plan->f, this_iplan->r_iter,\n\t  this_iplan->direct_plan->M);\n  \n  SWAPC(this_iplan->z_hat_iter,this_iplan->direct_plan->f_hat);\n  nfft_adjoint(this_iplan->direct_plan);\n  SWAPC(this_iplan->z_hat_iter,this_iplan->direct_plan->f_hat);\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    this_iplan->dot_z_hat_iter =\n      dotproductc_w(this_iplan->z_hat_iter, this_iplan->w_hat, \n\t\t    this_iplan->direct_plan->N_L);\n  else\n    this_iplan->dot_z_hat_iter =\n      dotproductc(this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n} /* void infft_loop_one_step_steepest_descent */\n\nvoid infft_loop_one_step_cgnr_e(infft_plan *this_iplan)\n{\n  /** step 9\n   *  overwrites this_iplan->direct_plan->f_hat \n   *  overwrites this_iplan->v_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    copyc_w(this_iplan->direct_plan->f_hat, this_iplan->w_hat,\n\t    this_iplan->p_hat_iter, this_iplan->direct_plan->N_L);\n  else\n    copyc(this_iplan->direct_plan->f_hat, this_iplan->p_hat_iter,\n\t  this_iplan->direct_plan->N_L);\n  \n  SWAPC(this_iplan->v_iter,this_iplan->direct_plan->f);\n  nfft_trafo(this_iplan->direct_plan);\n  SWAPC(this_iplan->v_iter,this_iplan->direct_plan->f);\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    this_iplan->dot_v_iter = dotproductc_w(this_iplan->v_iter, this_iplan->w,\n\t\t\t\t\t   this_iplan->direct_plan->M);\n  else\n    this_iplan->dot_v_iter =\n      dotproductc(this_iplan->v_iter, this_iplan->direct_plan->M);\n  \n  /** step 10\n   */\n  this_iplan->alpha_iter =\n    this_iplan->dot_z_hat_iter / this_iplan->dot_v_iter;\n\n  /** step 11\n   *  updates this_iplan->f_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    updatec_xpawy(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\t  this_iplan->w_hat, this_iplan->p_hat_iter,\n\t\t  this_iplan->direct_plan->N_L);\n  else\n    updatec_xpay(this_iplan->f_hat_iter, this_iplan->alpha_iter, \n\t\tthis_iplan->p_hat_iter, this_iplan->direct_plan->N_L);\n\n  /** step 12-15\n   *  updates this_iplan->f_hat_iter_2nd\n   */\n  if(this_iplan->infft_flags & ITERATE_2nd)\n    {\n      this_iplan->alpha_iter_2nd =\n\tthis_iplan->dot_r_iter / this_iplan->dot_z_hat_iter;\n      \n      if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n\tupdatec_xpawy(this_iplan->f_hat_iter_2nd, this_iplan->alpha_iter_2nd,\n\t\t      this_iplan->w_hat, this_iplan->z_hat_iter,\n\t\t      this_iplan->direct_plan->N_L);\n      else\n\tupdatec_xpay(this_iplan->f_hat_iter_2nd, this_iplan->alpha_iter_2nd,\n\t\t    this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n    }\n  \n  /** step 16\n   *  updates this_iplan->r_iter\n   */\n  updatec_xpay(this_iplan->r_iter, -this_iplan->alpha_iter, this_iplan->v_iter,\n\t      this_iplan->direct_plan->M);\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    this_iplan->dot_r_iter = dotproductc_w(this_iplan->r_iter, this_iplan->w,\n\t\t\t\t\t   this_iplan->direct_plan->M);\n  else\n    this_iplan->dot_r_iter =\n      dotproductc(this_iplan->r_iter, this_iplan->direct_plan->M);\n\n  /** step 17\n   *  overwrites this_iplan->direct_plan->f\n   *  overwrites this_iplan->direct_plan->r_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    copyc_w(this_iplan->direct_plan->f, this_iplan->w, \n\t    this_iplan->r_iter, this_iplan->direct_plan->M);\n  else\n    copyc(this_iplan->direct_plan->f, this_iplan->r_iter,\n\t  this_iplan->direct_plan->M);\n  \n  SWAPC(this_iplan->z_hat_iter,this_iplan->direct_plan->f_hat);\n  nfft_adjoint(this_iplan->direct_plan);\n  SWAPC(this_iplan->z_hat_iter,this_iplan->direct_plan->f_hat);\n\n  this_iplan->dot_z_hat_iter_old = this_iplan->dot_z_hat_iter;\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    this_iplan->dot_z_hat_iter =\n      dotproductc_w(this_iplan->z_hat_iter, this_iplan->w_hat, \n\t\t    this_iplan->direct_plan->N_L);\n  else\n    this_iplan->dot_z_hat_iter =\n      dotproductc(this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n  \n  /** step 18\n   */\n  this_iplan->beta_iter =\n    this_iplan->dot_z_hat_iter / this_iplan->dot_z_hat_iter_old;\n  \n  /** step 19\n   *  updates this_iplan->p_hat_iter\n   */\n  updatec_axpy(this_iplan->p_hat_iter, this_iplan->beta_iter, \n\t       this_iplan->z_hat_iter, this_iplan->direct_plan->N_L);\n} /* void infft_loop_one_step_cgnr_e */\n\nvoid infft_loop_one_step_cgne_r(infft_plan *this_iplan)\n{\n  /** step 9\n   */\n  this_iplan->alpha_iter =\n    this_iplan->dot_r_iter / this_iplan->dot_p_hat_iter;\n  \n  /** step 10\n   *  updates this_iplan->f_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    updatec_xpawy(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\t  this_iplan->w_hat, this_iplan->p_hat_iter,\n\t\t  this_iplan->direct_plan->N_L);\n  else\n    updatec_xpay(this_iplan->f_hat_iter, this_iplan->alpha_iter,\n\t\tthis_iplan->p_hat_iter, this_iplan->direct_plan->N_L);\n  \n  /** step 11\n   *  overwrites this_iplan->direct_plan->f_hat \n   *  overwrites this_iplan->direct_plan->f\n   *  updates this_iplan->r_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    copyc_w(this_iplan->direct_plan->f_hat, this_iplan->w_hat,\n\t    this_iplan->p_hat_iter, this_iplan->direct_plan->N_L);\n  else\n    copyc(this_iplan->direct_plan->f_hat, this_iplan->p_hat_iter,\n\t  this_iplan->direct_plan->N_L);\n  \n  nfft_trafo(this_iplan->direct_plan);\n\n  updatec_xpay(this_iplan->r_iter, -this_iplan->alpha_iter,\n\t      this_iplan->direct_plan->f, this_iplan->direct_plan->M);\n  \n  this_iplan->dot_r_iter_old = this_iplan->dot_r_iter;\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    this_iplan->dot_r_iter =\n      dotproductc_w(this_iplan->r_iter, this_iplan->w,\n\t\t    this_iplan->direct_plan->M);\n  else\n    this_iplan->dot_r_iter =\n      dotproductc(this_iplan->r_iter, this_iplan->direct_plan->M);\n  \n  /** step 12\n   */\n  this_iplan->beta_iter =\n    this_iplan->dot_r_iter / this_iplan->dot_r_iter_old;\n  \n  /** step 13-16\n   *  updates this_iplan->f_hat_iter_2nd\n   */\n  if(this_iplan->infft_flags & ITERATE_2nd)\n    {\n      this_iplan->gamma_iter_old = this_iplan->gamma_iter;\n      this_iplan->gamma_iter =\n\tthis_iplan->beta_iter * this_iplan->gamma_iter_old + 1;\n      \n      updatec_axpby(this_iplan->f_hat_iter_2nd, \n\t\t    this_iplan->beta_iter * this_iplan->gamma_iter_old / \n\t\t    this_iplan->gamma_iter, this_iplan->f_hat_iter, \n\t\t    1.0 / this_iplan->gamma_iter, this_iplan->direct_plan->N_L);\n    }\n  \n  /** step 16\n   *  overwrites this_iplan->direct_plan->f\n   *  overwrites this_iplan->direct_plan->f_hat\n   *  updates this_iplan->p_hat_iter\n   */\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    copyc_w(this_iplan->direct_plan->f, this_iplan->w,\n\t    this_iplan->r_iter, this_iplan->direct_plan->M);\n  else\n    copyc(this_iplan->direct_plan->f, this_iplan->r_iter,\n\t  this_iplan->direct_plan->M); \n  \n  nfft_adjoint(this_iplan->direct_plan);\n  \n  updatec_axpy(this_iplan->p_hat_iter, this_iplan->beta_iter,\n\t       this_iplan->direct_plan->f_hat, this_iplan->direct_plan->N_L);\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    this_iplan->dot_p_hat_iter = \n      dotproductc_w(this_iplan->p_hat_iter, this_iplan->w_hat,\n\t\t    this_iplan->direct_plan->N_L);\n  else\n    this_iplan->dot_p_hat_iter =\n      dotproductc(this_iplan->p_hat_iter, this_iplan->direct_plan->N_L);\n}\n\nvoid infft_loop_one_step(infft_plan *this_iplan)\n{\n  if(this_iplan->infft_flags & LANDWEBER)\n    infft_loop_one_step_landweber(this_iplan);\n\n  if(this_iplan->infft_flags & STEEPEST_DESCENT)\n    infft_loop_one_step_steepest_descent(this_iplan);\n  \n  if(this_iplan->infft_flags & CGNR_E)\n    infft_loop_one_step_cgnr_e(this_iplan);\n  \n  if(this_iplan->infft_flags & CGNE_R)\n    infft_loop_one_step_cgne_r(this_iplan);\n}\n\nvoid infft_finalize(infft_plan *this_iplan)\n{\n  if(this_iplan->infft_flags & PRECOMPUTE_WEIGHT)\n    fftw_free(this_iplan->w);\n  \n  if(this_iplan->infft_flags & PRECOMPUTE_DAMP)\n    fftw_free(this_iplan->w_hat);\n  \n  if(this_iplan->infft_flags & ITERATE_2nd)\n    fftw_free(this_iplan->f_hat_iter_2nd);\n  \n  if(this_iplan->infft_flags & CGNR_E)\n    {\n      fftw_free(this_iplan->v_iter);\n      fftw_free(this_iplan->z_hat_iter);\n    }\n  \n  if(this_iplan->infft_flags & STEEPEST_DESCENT)\n    fftw_free(this_iplan->v_iter);\n  \n  fftw_free(this_iplan->p_hat_iter);\n  fftw_free(this_iplan->f_hat_iter);\n\n  fftw_free(this_iplan->r_iter);\n  fftw_free(this_iplan->given_f);\n}\n";
		rLen = 17550;
		rLoc = 35159;
		rType = 0;
		vrLen = 945;
		vrLoc = 52061;
	};
	4E29328E082E50BD004AD73C = {
		fRef = 4E293281082E501F004AD73C;
		isa = PBXTextBookmark;
		name = "infsft.h: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 40;
		vrLoc = 0;
	};
	4E2932A7082E5984004AD73C = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {734, 1728}}";
			sepNavSelRange = "{1588, 0}";
			sepNavVisRect = "{{0, 1013}, {734, 295}}";
			sepNavWindowFrame = "{{0, 71}, {1280, 761}}";
		};
	};
	4E2932B3082E5ABD004AD73C = {
		fRef = 4E2932A7082E5984004AD73C;
		isa = PBXTextBookmark;
		name = "template.c: 1";
		rLen = 0;
		rLoc = 2210;
		rType = 0;
		vrLen = 0;
		vrLoc = 0;
	};
	4E29331A082E672F004AD73C = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 3599}}";
			sepNavSelRange = "{4412, 0}";
			sepNavVisRect = "{{0, 2598}, {910, 576}}";
			sepNavWindowFrame = "{{0, 71}, {1280, 761}}";
		};
	};
	4E29332B082E67D9004AD73C = {
		fRef = 4E29331A082E672F004AD73C;
		isa = PBXTextBookmark;
		name = "wrapper.c: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 1082;
		vrLoc = 0;
	};
	4E294D5008575D3600F546C3 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {937, 4719}}";
			sepNavSelRange = "{5417, 10}";
			sepNavVisRect = "{{0, 3541}, {734, 295}}";
		};
	};
	4E294DA908577C8700F546C3 = {
		fRef = 4E6E40C2082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "nfft.c: 451";
		rLen = 0;
		rLoc = 26039;
		rType = 0;
		vrLen = 748;
		vrLoc = 25511;
	};
	4E5470A208329F8600CA0375 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {1385, 12703}}";
			sepNavSelRange = "{861, 20514}";
			sepNavVisRect = "{{0, 12233}, {912, 470}}";
		};
	};
	4E5470E10832A31200CA0375 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 8639}}";
			sepNavSelRange = "{79, 4}";
			sepNavVisRect = "{{0, 0}, {912, 470}}";
		};
	};
	4E5470E20832A31200CA0375 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 783}}";
			sepNavSelRange = "{1694, 0}";
			sepNavVisRect = "{{0, 0}, {910, 470}}";
		};
	};
	4E5471090832A94F00CA0375 = {
		fRef = 4E5470E20832A31200CA0375;
		isa = PBXTextBookmark;
		name = "void flft(int M, int t, int n, complex *f_hat, struct U_type ***U, \n          struct nfsft_transform_wisdom *tw);\n";
		rLen = 107;
		rLoc = 556;
		rType = 0;
		vrLen = 794;
		vrLoc = 0;
	};
	4E6A5CA0082EA09E00ED6FD8 = {
		fRef = 4E6E40C4082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "options.h: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 1401;
		vrLoc = 0;
	};
	4E6A5CA3082EA09E00ED6FD8 = {
		fRef = 4E6E40C4082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "options.h: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 1401;
		vrLoc = 0;
	};
	4E6A5CA7082EA12700ED6FD8 = {
		isa = PBXFileReference;
		lastKnownFileType = sourcecode.cpp.cpp;
		name = group.cpp;
		path = /sw/share/doc/doxygen/examples/group.cpp;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4E6A5CA8082EA12700ED6FD8 = {
		fRef = 4E6E40C3082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "nfft.h: 127";
		rLen = 0;
		rLoc = 5103;
		rType = 0;
		vrLen = 1442;
		vrLoc = 4339;
	};
	4E6A5CBD082EA20000ED6FD8 = {
		fRef = 4E6A5CA7082EA12700ED6FD8;
		isa = PBXTextBookmark;
		name = "@defgroup group1";
		rLen = 16;
		rLoc = 4;
		rType = 0;
		vrLen = 563;
		vrLoc = 0;
	};
	4E6A5CC3082EA20000ED6FD8 = {
		fRef = 4E6A5CA7082EA12700ED6FD8;
		isa = PBXTextBookmark;
		name = "@defgroup group1";
		rLen = 16;
		rLoc = 4;
		rType = 0;
		vrLen = 563;
		vrLoc = 0;
	};
	4E6C0277085316E90095AA39 = {
		fRef = 4E6CD57607C54E630040176B;
		isa = PBXTextBookmark;
		name = "legendre.c: 178";
		rLen = 0;
		rLoc = 3661;
		rType = 0;
		vrLen = 2;
		vrLoc = 3658;
	};
	4E6C0285085318950095AA39 = {
		fRef = 4E6CD56E07C54E170040176B;
		isa = PBXTextBookmark;
		name = "legendre.h: 100";
		rLen = 0;
		rLoc = 2561;
		rType = 0;
		vrLen = 834;
		vrLoc = 2223;
	};
	4E6C5EC8088E96680051B166 = {
		fRef = 4E8A26E10838C49000216481;
		isa = PBXTextBookmark;
		name = "performance.c: 166";
		rLen = 0;
		rLoc = 3828;
		rType = 0;
		vrLen = 833;
		vrLoc = 3367;
	};
	4E6C5ECE088E96C10051B166 = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "accuracy.c: 415";
		rLen = 0;
		rLoc = 10872;
		rType = 0;
		vrLen = 705;
		vrLoc = 10713;
	};
	4E6CD54507C54A7E0040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 2719}}";
			sepNavSelRange = "{859, 65}";
			sepNavVisRect = "{{0, 534}, {912, 470}}";
		};
	};
	4E6CD54607C54A7E0040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 1391}}";
			sepNavSelRange = "{2208, 0}";
			sepNavVisRect = "{{0, 810}, {912, 470}}";
			sepNavWindowFrame = "{{15, 77}, {1280, 755}}";
		};
	};
	4E6CD54A07C54A7E0040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 7775}}";
			sepNavSelRange = "{13234, 0}";
			sepNavVisRect = "{{0, 7305}, {912, 470}}";
			sepNavWindowFrame = "{{72, 109}, {1280, 755}}";
		};
	};
	4E6CD54B07C54A7E0040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 3583}}";
			sepNavSelRange = "{3287, 16}";
			sepNavVisRect = "{{0, 2061}, {912, 470}}";
		};
	};
	4E6CD54C07C54A7E0040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 8031}}";
			sepNavSelRange = "{3182, 44}";
			sepNavVisRect = "{{0, 3104}, {912, 470}}";
		};
	};
	4E6CD54D07C54A7E0040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 847}}";
			sepNavSelRange = "{1000, 0}";
			sepNavVisRect = "{{0, 240}, {912, 470}}";
		};
	};
	4E6CD56E07C54E170040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 2095}}";
			sepNavSelRange = "{1005, 8}";
			sepNavVisRect = "{{0, 0}, {910, 470}}";
		};
	};
	4E6CD57607C54E630040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 3087}}";
			sepNavSelRange = "{1303, 12}";
			sepNavVisRect = "{{0, 0}, {910, 470}}";
		};
	};
	4E6CD5D607C555500040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 1215}}";
			sepNavSelRange = "{178, 0}";
			sepNavVisRect = "{{0, 16}, {912, 470}}";
		};
	};
	4E6CD5D707C555500040176B = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 3887}}";
			sepNavSelRange = "{3406, 13}";
			sepNavVisRect = "{{0, 10}, {912, 470}}";
		};
	};
	4E6E40C2082CB46F00642FF0 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 21983}}";
			sepNavSelRange = "{26039, 0}";
			sepNavVisRect = "{{0, 6877}, {910, 470}}";
			sepNavWindowFrame = "{{15, 77}, {1280, 755}}";
		};
	};
	4E6E40C3082CB46F00642FF0 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 4191}}";
			sepNavSelRange = "{6185, 12}";
			sepNavVisRect = "{{0, 2060}, {910, 470}}";
		};
	};
	4E6E40C4082CB46F00642FF0 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {943, 655}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {943, 576}}";
		};
	};
	4E6E40C5082CB46F00642FF0 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 19055}}";
			sepNavSelRange = "{20652, 62}";
			sepNavVisRect = "{{0, 13709}, {912, 470}}";
		};
	};
	4E6E40C6082CB46F00642FF0 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {964, 3023}}";
			sepNavSelRange = "{2905, 0}";
			sepNavVisRect = "{{0, 1757}, {964, 470}}";
		};
	};
	4E6E40E9082CB6C600642FF0 = {
		activeArgIndex = 0;
		activeArgIndices = (
			YES,
		);
		argumentStrings = (
			"< ../matlab/temp.in",
		);
		configStateDict = {
			"PBXLSLaunchAction-0" = {
				PBXLSLaunchAction = 0;
				PBXLSLaunchStartAction = 1;
				PBXLSLaunchStdioStyle = 2;
				PBXLSLaunchStyle = 0;
				class = PBXLSRunLaunchConfig;
				displayName = "Executable Runner";
				identifier = com.apple.Xcode.launch.runConfig;
				remoteHostInfo = "";
				startActionInfo = "";
			};
		};
		cppStopOnCatchEnabled = 0;
		cppStopOnThrowEnabled = 0;
		customDataFormattersEnabled = 1;
		debuggerPlugin = GDBDebugging;
		disassemblyDisplayState = 0;
		dylibVariantSuffix = "";
		enableDebugStr = 1;
		environmentEntries = (
		);
		isa = PBXExecutable;
		launchableReference = 4E6E40EA082CB6C600642FF0;
		libgmallocEnabled = 0;
		name = NFSFT2;
		shlibInfoDictList = (
		);
		sourceDirectories = (
		);
		startupPath = /Users/keiner/Temporary/nfft/examples;
	};
	4E6E40EA082CB6C600642FF0 = {
		isa = PBXFileReference;
		lastKnownFileType = file;
		name = nfsft2;
		path = /Users/keiner/Temporary/nfft/examples/nfsft2;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4E6E72130855C89400D77920 = {
		fRef = 4E23D9390854D1E300CC656A;
		isa = PBXTextBookmark;
		name = "egm96.c: 170";
		rLen = 0;
		rLoc = 4052;
		rType = 0;
		vrLen = 519;
		vrLoc = 3946;
	};
	4E6EA365083E95C9004C5D07 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 4383}}";
			sepNavSelRange = "{5685, 0}";
			sepNavVisRect = "{{0, 2448}, {910, 470}}";
		};
	};
	4E7021F30886930C00CBA928 = {
		fRef = 4E6CD54C07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "inline long int maxl(const long int a, const long int b)";
		rLen = 56;
		rLoc = 7999;
		rType = 0;
		vrLen = 401;
		vrLoc = 7313;
	};
	4E7021F40886930C00CBA928 = {
		fRef = 4E6CD54D07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "util.h: maxl";
		rLen = 0;
		rLoc = 1075;
		rType = 0;
		vrLen = 1005;
		vrLoc = 31;
	};
	4E7021F70886930C00CBA928 = {
		fRef = 4E6CD54C07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "inline long int maxl(const long int a, const long int b)";
		rLen = 56;
		rLoc = 7999;
		rType = 0;
		vrLen = 401;
		vrLoc = 7313;
	};
	4E7021F80886930C00CBA928 = {
		fRef = 4E6CD54D07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "util.h: maxl";
		rLen = 0;
		rLoc = 1075;
		rType = 0;
		vrLen = 1005;
		vrLoc = 31;
	};
	4E7022200887F8C700CBA928 = {
		fRef = 4E5470A208329F8600CA0375;
		isa = PBXTextBookmark;
		name = "summation.c: 721";
		rLen = 0;
		rLoc = 19324;
		rType = 0;
		vrLen = 412;
		vrLoc = 20963;
	};
	4E7022210887F8C700CBA928 = {
		fRef = 4E5470A208329F8600CA0375;
		isa = PBXTextBookmark;
		name = "summation.c: 721";
		rLen = 0;
		rLoc = 19324;
		rType = 0;
		vrLen = 412;
		vrLoc = 20963;
	};
	4E720984084F7DAE007F8CEA = {
		fRef = 4E6E40C5082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = copyc;
		rLen = 5;
		rLoc = 19834;
		rType = 0;
		vrLen = 545;
		vrLoc = 19540;
	};
	4E75157F082C0CF4002018A8 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 1119}}";
			sepNavSelRange = "{377, 0}";
			sepNavVisRect = "{{0, 0}, {912, 470}}";
		};
	};
	4E751580082C0CF4002018A8 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 12975}}";
			sepNavSelRange = "{26848, 25}";
			sepNavVisRect = "{{0, 11872}, {912, 470}}";
			sepNavWindowFrame = "{{15, 73}, {1280, 861}}";
		};
	};
	4E751588082C0D65002018A8 = {
		fRef = 4E75157F082C0CF4002018A8;
		isa = PBXTextBookmark;
		name = "u.h: 1";
		rLen = 0;
		rLoc = 287;
		rType = 0;
		vrLen = 159;
		vrLoc = 0;
	};
	4E757C62087FDC0C0027229F = {
		fRef = 4E9F7CAA0851D7A700952ECD;
		isa = PBXTextBookmark;
		name = "stabilization.c: 102";
		rLen = 0;
		rLoc = 2384;
		rType = 0;
		vrLen = 1091;
		vrLoc = 1391;
	};
	4E7692190852D4160088C885 = {
		fRef = 4E6E40C6082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "utils.h: error";
		rLen = 0;
		rLoc = 2905;
		rType = 0;
		vrLen = 878;
		vrLoc = 2469;
	};
	4E7848BA08903A1600842C4C = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "accuracy.c: 436";
		rLen = 0;
		rLoc = 11378;
		rType = 0;
		vrLen = 675;
		vrLoc = 11028;
	};
	4E8A26AA0838C11700216481 = {
		fRef = 4E6CD5D607C555500040176B;
		isa = PBXTextBookmark;
		name = "direct.h: adjoint_ndsft2";
		rLen = 0;
		rLoc = 3027;
		rType = 0;
		vrLen = 1507;
		vrLoc = 1500;
	};
	4E8A26E10838C49000216481 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 3407}}";
			sepNavSelRange = "{3828, 0}";
			sepNavVisRect = "{{0, 2384}, {912, 470}}";
		};
	};
	4E8A27670838E2CF00216481 = {
		fRef = 4E13CA0B07EB1770003D3B6C;
		isa = PBXTextBookmark;
		name = "fftw3.h: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 1463;
		vrLoc = 7977;
	};
	4E8E5792083E4CA60061697E = {
		fRef = 4E6E40C6082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = SWAPC;
		rLen = 5;
		rLoc = 272;
		rType = 0;
		vrLen = 624;
		vrLoc = 75;
	};
	4E8F44930850B4800098CEFF = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 2703}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {912, 470}}";
		};
	};
	4E8F44940850B4800098CEFF = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {910, 607}}";
			sepNavSelRange = "{592, 0}";
			sepNavVisRect = "{{0, 0}, {910, 470}}";
		};
	};
	4E8F457B0850CE760098CEFF = {
		fRef = 4E0887C0071585CD005706CD;
		isa = PBXTextBookmark;
		name = log;
		rLen = 3;
		rLoc = 735;
		rType = 0;
		vrLen = 1386;
		vrLoc = 0;
	};
	4E8F45840850CE760098CEFF = {
		fRef = 4E0887C0071585CD005706CD;
		isa = PBXTextBookmark;
		name = log;
		rLen = 3;
		rLoc = 735;
		rType = 0;
		vrLen = 1386;
		vrLoc = 0;
	};
	4E8FDDA5088A73E10098D700 = {
		fRef = 4E6CD5D607C555500040176B;
		isa = PBXTextBookmark;
		name = "direct.h: 11";
		rLen = 0;
		rLoc = 178;
		rType = 0;
		vrLen = 982;
		vrLoc = 4;
	};
	4E8FDDA6088A73E10098D700 = {
		fRef = 4E751580082C0CF4002018A8;
		isa = PBXTextBookmark;
		name = "polynomials for the curre";
		rLen = 25;
		rLoc = 26848;
		rType = 0;
		vrLen = 684;
		vrLoc = 26638;
	};
	4E8FDDA7088A73E10098D700 = {
		fRef = 4E75157F082C0CF4002018A8;
		isa = PBXTextBookmark;
		name = "u.h: 16";
		rLen = 0;
		rLoc = 377;
		rType = 0;
		vrLen = 763;
		vrLoc = 0;
	};
	4E8FDDA8088A73E10098D700 = {
		fRef = 4E6CD54507C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "/** \\defgroup nfsft_internal NFSFT: Internal API and functions */";
		rLen = 65;
		rLoc = 859;
		rType = 0;
		vrLen = 656;
		vrLoc = 552;
	};
	4E8FDDB3088A73E10098D700 = {
		fRef = 4E751580082C0CF4002018A8;
		isa = PBXTextBookmark;
		name = "polynomials for the curre";
		rLen = 25;
		rLoc = 26848;
		rType = 0;
		vrLen = 684;
		vrLoc = 26638;
	};
	4E8FDDD8088AC08F0098D700 = {
		fRef = 4E9F7CAA0851D7A700952ECD;
		isa = PBXTextBookmark;
		name = "stabilization.c: 102";
		rLen = 0;
		rLoc = 2384;
		rType = 0;
		vrLen = 821;
		vrLoc = 1687;
	};
	4E8FDDEA088AC0F70098D700 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 470}}";
			sepNavSelRange = "{0, 0}";
			sepNavVisRect = "{{0, 0}, {912, 470}}";
		};
	};
	4E8FDDEC088AC0FA0098D700 = {
		fRef = 4E8F44930850B4800098CEFF;
		isa = PBXTextBookmark;
		name = "c2f.c: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 873;
		vrLoc = 0;
	};
	4E8FDDF0088AC2F80098D700 = {
		fRef = 4E8FDDEA088AC0F70098D700;
		isa = PBXTextBookmark;
		name = "dpt.c: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 130;
		vrLoc = 0;
	};
	4E8FDDF1088AC2F80098D700 = {
		fRef = 4E6CD54B07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = nfsft_precompute;
		rLen = 16;
		rLoc = 3287;
		rType = 0;
		vrLen = 864;
		vrLoc = 2838;
	};
	4E8FDDF2088AC2F80098D700 = {
		fRef = 4E6CD54607C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "config.h: PACKAGE_VERSION";
		rLen = 0;
		rLoc = 2208;
		rType = 0;
		vrLen = 807;
		vrLoc = 1404;
	};
	4E8FDDF5088AC2F80098D700 = {
		fRef = 4E8FDDEA088AC0F70098D700;
		isa = PBXTextBookmark;
		name = "dpt.c: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 130;
		vrLoc = 0;
	};
	4E8FDDF7088AC2F80098D700 = {
		fRef = 4E6CD54A07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "nfsft.c: 499";
		rLen = 0;
		rLoc = 13320;
		rType = 0;
		vrLen = 516;
		vrLoc = 13091;
	};
	4E8FDDFC088AC2F80098D700 = {
		fRef = 4E6CD54607C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "config.h: PACKAGE_VERSION";
		rLen = 0;
		rLoc = 2208;
		rType = 0;
		vrLen = 807;
		vrLoc = 1404;
	};
	4E8FDE04088AC3610098D700 = {
		fRef = 4E5470E10832A31200CA0375;
		isa = PBXTextBookmark;
		name = flft;
		rLen = 4;
		rLoc = 79;
		rType = 0;
		vrLen = 862;
		vrLoc = 0;
	};
	4E8FDE12088AC7020098D700 = {
		fRef = 4E98AAA1084A0B790002D4FC;
		isa = PBXTextBookmark;
		name = "flft.c: 82";
		rLen = 0;
		rLoc = 1907;
		rType = 0;
		vrLen = 635;
		vrLoc = 1627;
	};
	4E8FDE19088AF3D40098D700 = {
		fRef = 4E6CD54A07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "nfsft.c: 478";
		rLen = 0;
		rLoc = 13234;
		rType = 0;
		vrLen = 514;
		vrLoc = 12844;
	};
	4E8FDE1B088AF3D40098D700 = {
		fRef = 4E6CD5D707C555500040176B;
		isa = PBXTextBookmark;
		name = adjoint_ndsft;
		rLen = 13;
		rLoc = 3406;
		rType = 0;
		vrLen = 695;
		vrLoc = 0;
	};
	4E8FDE1F088AF3D40098D700 = {
		fRef = 4E6CD5D707C555500040176B;
		isa = PBXTextBookmark;
		name = adjoint_ndsft;
		rLen = 13;
		rLoc = 3406;
		rType = 0;
		vrLen = 695;
		vrLoc = 0;
	};
	4E98AAA1084A0B790002D4FC = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 1615}}";
			sepNavSelRange = "{1907, 0}";
			sepNavVisRect = "{{0, 1145}, {912, 470}}";
		};
	};
	4E98AAC2084A23820002D4FC = {
		fRef = 4E98AAA1084A0B790002D4FC;
		isa = PBXTextBookmark;
		name = "flft.c: 72";
		rLen = 0;
		rLoc = 1490;
		rType = 0;
		vrLen = 679;
		vrLoc = 1489;
	};
	4E9F7CAA0851D7A700952ECD = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 1792}}";
			sepNavSelRange = "{2384, 0}";
			sepNavVisRect = "{{0, 1306}, {912, 470}}";
		};
	};
	4E9F7CAC0851DA3100952ECD = {
		fRef = 4E2932A7082E5984004AD73C;
		isa = PBXTextBookmark;
		name = "template.c: 18";
		rLen = 0;
		rLoc = 247;
		rType = 0;
		vrLen = 578;
		vrLoc = 1679;
	};
	4EA42B57087E6423004F81E3 = {
		fRef = 4E6EA365083E95C9004C5D07;
		isa = PBXTextBookmark;
		name = "inverse.c: 239";
		rLen = 0;
		rLoc = 5685;
		rType = 0;
		vrLen = 743;
		vrLoc = 3913;
	};
	4EAB55900879C3B700919EC9 = {
		fRef = 4EE9EBCD0878767600880508;
		isa = PBXTextBookmark;
		name = "interpolation.c: 79";
		rLen = 0;
		rLoc = 1772;
		rType = 0;
		vrLen = 562;
		vrLoc = 1225;
	};
	4EAD692A083BC9A900C61F13 = {
		isa = PBXFileReference;
		lastKnownFileType = text;
		name = headers.m4;
		path = /sw/share/autoconf/autoconf/headers.m4;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4EAD6954083BD14300C61F13 = {
		fRef = 4E8A26E10838C49000216481;
		isa = PBXTextBookmark;
		name = "performance.c: 84";
		rLen = 0;
		rLoc = 2011;
		rType = 0;
		vrLen = 952;
		vrLoc = 3963;
	};
	4EAD6963083BD20500C61F13 = {
		isa = PBXFileReference;
		lastKnownFileType = text;
		name = general.m4;
		path = /sw/share/autoconf/autoconf/general.m4;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4EAD6969083BD39C00C61F13 = {
		fRef = 4EAD6963083BD20500C61F13;
		isa = PBXTextBookmark;
		name = AC_REQUIRE;
		rLen = 10;
		rLoc = 5700;
		rType = 0;
		vrLen = 996;
		vrLoc = 5286;
	};
	4EAD696A083BD39C00C61F13 = {
		fRef = 4EAD692A083BC9A900C61F13;
		isa = PBXTextBookmark;
		name = AC_REQUIRE;
		rLen = 10;
		rLoc = 10098;
		rType = 0;
		vrLen = 1212;
		vrLoc = 9454;
	};
	4EAD69A2083BE07E00C61F13 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 8559}}";
			sepNavSelRange = "{11378, 0}";
			sepNavVisRect = "{{0, 6736}, {912, 470}}";
		};
	};
	4EB20A1E07D4B30C00FD1AB8 = {
		activeArgIndex = 8;
		activeArgIndices = (
			NO,
			NO,
			NO,
			NO,
			NO,
			NO,
			NO,
			NO,
			YES,
		);
		argumentStrings = (
			"< ../../matlab/temp.in",
			"> ../matlab/temp.out",
			"498 1024 1 1000 1000 1 0",
			4,
			"64 64 1 2000 2000 1 0",
			"0 128 1 1000 10000 1000",
			"1 32 1 2000 2000 1 0",
			"513 1024 1 2000 2000 1 0",
			"< locsupp.in",
		);
		configStateDict = {
			"PBXLSLaunchAction-0" = {
				PBXLSLaunchAction = 0;
				PBXLSLaunchStartAction = 1;
				PBXLSLaunchStdioStyle = 2;
				PBXLSLaunchStyle = 0;
				class = PBXLSRunLaunchConfig;
				displayName = "Executable Runner";
				identifier = com.apple.Xcode.launch.runConfig;
				remoteHostInfo = "";
				startActionInfo = "";
			};
		};
		cppStopOnCatchEnabled = 0;
		cppStopOnThrowEnabled = 0;
		customDataFormattersEnabled = 1;
		debuggerPlugin = GDBDebugging;
		disassemblyDisplayState = 0;
		dylibVariantSuffix = "";
		enableDebugStr = 1;
		environmentEntries = (
		);
		isa = PBXExecutable;
		libgmallocEnabled = 0;
		name = NFSFT;
		savedGlobals = {
		};
		shlibInfoDictList = (
		);
		sourceDirectories = (
		);
		startupPath = /Users/keiner/Temporary/trunk/obsolete/keiner/tests/summation;
	};
	4EB6E510083143AE003AAA48 = {
		fRef = 4E02C48E082F816D00EC0863;
		isa = PBXTextBookmark;
		name = "convolution.c: 104";
		rLen = 0;
		rLoc = 5094;
		rType = 0;
		vrLen = 598;
		vrLoc = 2261;
	};
	4ECF7CD3087BC75A00F4A43E = {
		fRef = 4E8F44940850B4800098CEFF;
		isa = PBXTextBookmark;
		name = "c2f.h: 34";
		rLen = 0;
		rLoc = 592;
		rType = 0;
		vrLen = 539;
		vrLoc = 0;
	};
	4ECF7CD4087BC75A00F4A43E = {
		fRef = 4E293281082E501F004AD73C;
		isa = PBXTextBookmark;
		name = "infsft.h: NFSFT_PRECOMPUTE_DAMP";
		rLen = 0;
		rLoc = 307;
		rType = 0;
		vrLen = 749;
		vrLoc = 0;
	};
	4ECF7CD5087BC75A00F4A43E = {
		fRef = 4E293282082E501F004AD73C;
		isa = PBXTextBookmark;
		name = "infsft.c: 439";
		rLen = 0;
		rLoc = 14850;
		rType = 0;
		vrLen = 755;
		vrLoc = 0;
	};
	4ECF7CD7087BC75A00F4A43E = {
		fRef = 4E5470E20832A31200CA0375;
		isa = PBXTextBookmark;
		name = "flft.h: 46";
		rLen = 0;
		rLoc = 1694;
		rType = 0;
		vrLen = 955;
		vrLoc = 0;
	};
	4ECF7CDC087BC75A00F4A43E = {
		fRef = 4E6CD56E07C54E170040176B;
		isa = PBXTextBookmark;
		name = gamma_al;
		rLen = 8;
		rLoc = 1005;
		rType = 0;
		vrLen = 649;
		vrLoc = 0;
	};
	4ECF7CDD087BC75A00F4A43E = {
		fRef = 4E6CD57607C54E630040176B;
		isa = PBXTextBookmark;
		name = gamma_al_all;
		rLen = 12;
		rLoc = 1303;
		rType = 0;
		vrLen = 382;
		vrLoc = 0;
	};
	4ECF7CDF087BC75A00F4A43E = {
		fRef = 4E8F44930850B4800098CEFF;
		isa = PBXTextBookmark;
		name = "c2f.c: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 873;
		vrLoc = 0;
	};
	4ECF7CE0087BC75A00F4A43E = {
		fRef = 4E8F44940850B4800098CEFF;
		isa = PBXTextBookmark;
		name = "c2f.h: 34";
		rLen = 0;
		rLoc = 592;
		rType = 0;
		vrLen = 539;
		vrLoc = 0;
	};
	4ED469F80890F0D400F4E929 = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "accuracy.c: 436";
		rLen = 0;
		rLoc = 11378;
		rType = 0;
		vrLen = 668;
		vrLoc = 11028;
	};
	4ED469F90890F0D400F4E929 = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "accuracy.c: 436";
		rLen = 0;
		rLoc = 11378;
		rType = 0;
		vrLen = 668;
		vrLoc = 11028;
	};
	4ED469FC0890F0E100F4E929 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {912, 4783}}";
			sepNavSelRange = "{6348, 0}";
			sepNavVisRect = "{{0, 2174}, {912, 470}}";
		};
	};
	4ED469FD0890F17700F4E929 = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "accuracy.c: 436";
		rLen = 0;
		rLoc = 11378;
		rType = 0;
		vrLen = 668;
		vrLoc = 11028;
	};
	4ED469FE0890F17700F4E929 = {
		fRef = 4E5470A208329F8600CA0375;
		isa = PBXTextBookmark;
		name = "#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#else\n#  error Need config.h\n#endif\n\n/* Auxilliary headers */\n#include <complex.h>\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n/* Library headers. */\n#include \"nfsft.h\"\n#include \"util.h\"\n#include \"../../nfft/utils.h\"\n\n/** The symbol of the Abel-Poisson kernel */\n#define SYMBOL_ABEL_POISSON(k,h) pow(h,k)\n/** The symbol of the singularity kernel */\n#define SYMBOL_SINGULARITY(k,h) (2.0/(2*k+1))*pow(h,k)\n\n/* Kernel types */\n/** Abel-Poisson kernel */\n#define KT_ABEL_POISSON (0)\n/** Singularity kernel */\n#define KT_SINGULARITY  (1)\n/** Locally supported kernel */\n#define KT_LOC_SUPP     (2)\n/** Gaussian kernel */\n#define KT_GAUSSIAN     (3)\n\n#define NO   (0)\n#define YES  (1)\n#define BOTH (2)\n\n/** Computes the inner product on \\f$\\mathbb{S}^2\\f$. */\ninline double innerProduct(const double phi1, const double theta1, \n                           const double phi2, const double theta2)\n{\n  return cos(theta1)*cos(theta2) + sin(theta1)*sin(theta2)*cos(phi1-phi2);\n}\n\n/** Evaluates the Poisson kernel. */\ninline double poissonKernel(const double x, const double h)\n{\n \treturn (1.0/(4*PI))*(1-h*h)/pow(sqrt(1-2*h*x+h*h),3);\n}\n\n/** Evaluates the singularity kernel. */\ninline double singularityKernel(const double x, const double h)\n{\n  return (1.0/(2*PI))/sqrt(1-2*h*x+h*h);\n}\n\n/** Evaluates the locally supported kernel. */\ninline double locSuppKernel(const double x, const double h, const double lambda)\n{\n \treturn (x<=h)?(0.0):(pow((x-h),lambda));\n}\n\n/** Evaluates the Gaussian kernel. */\ninline double gaussianKernel(const double x, const double rho)\n{\n \treturn exp(rho*(x-1));\n}\n\n/**\n * The main program.\n *\n * \\param argc The number of arguments\n * \\param argv An array containing the arguments as C-strings\n *\n * \\return Exit code \n */\nint main (int argc, char **argv)\n{  \n  /** An array containing the parameter sets for the current kernel. */\n  double **p;\n  /** An array containing the parameters \\f$M\\f$. */\n  int *m;\n  /** An array containing the parameters \\f$L\\f$ and \\f$D\\f$. */\n  int **ld;\n  /** Index variable for p */\n  int ip;\n  /** Index variable for m */\n  int im;\n  /** Index variable for l */\n  int ild;\n  /** Maximum index for p */\n  int ip_max;\n  /** Maximum index for m */\n  int im_max;\n  /** Maximum index for l */\n  int ild_max;\n\n  /** Number of testcases */\n  int tc_max;\n  /** Maximum \\f$M\\f$ for the current dataset */\n  int m_max;\n  /** Maximum \\f$L\\f$ for the current dataset */\n  int l_max;\n  /** Maximum \\f$D\\f$ for the current dataset */\n  int d_max;\n\tlong ld_max_prec;\n\tlong l_max_prec;\n  \n  /** Index variable for testcases. */\n  int tc;\n  /** The kernel type */\n  int kt;\n  int cutoff;\n  double threshold;\n  \n  /** Next greater power of two with respect to m_max */\n  int n_max;\n \t/** \n   * The relative error\n   * \n   * \\f[\n       \\frac{\\left\\|f-f_M\\right\\|_{\\infty}}{\\left\\|\\mathbf{b}\\right\\|}\n   * \\f]\n   */\n  double t_d, t_dp, t_fd, t_f;\n  double nfactor;\n  double temp;\n\tdouble err;\n\tdouble t;\n\tint precompute = NO;\n\tcomplex *ptr;\n\t\n  /** Weights \\f$\\left(b_l\\right)_{l=0}^{L-1}\\f$ */\n \tcomplex *b;\n  /** Fourier coefficients */\n  complex **f_hat;\n  /** Symbool coefficients */\n \tcomplex *a;\n  /** Target nodes */\n \tdouble *xi;\n  /** Source nodes */\n \tdouble *nu;\n  /** Approximate function values */\n \tcomplex *f_m;\n  /** Exact function values */\n  complex *f;\n  complex *prec;\n  /** NFSFT plan */\n \tnfsft_plan plan;\n  /** adjoint NFSFT plan */\n  nfsft_plan plan_adjoint;\n  \n \tint i,j,k,n,d,l,use_nfsft,use_nfft,nsymbols;\n\tlong index;\n\tint rinc;\n  \n  FILE *file_tex;\n  FILE *file_dat;\n  FILE *file_gaussian;\n  char filename_tex[100];\n  char filename_dat[100];\n  char filename_gaussian[100];\n\tdouble constant;\n\t \t\n  /* Read number of testcases. */\n  fscanf(stdin,\"testcases=%d\\n\",&tc_max);\n  \n  fprintf(stdout,\"Number of testcases: %d\\n\\n\",tc_max);\n  \n  /* Process testcases. */\n  for (tc = 0; tc < tc_max; tc++)\n  {\n    fprintf(stdout,\"Testcase %d:\\n\",tc);\n\n    fscanf(stdin,\"nfsft=%d\\n\",&use_nfsft);\n    if (use_nfsft != NO)\n  \t{\n      fprintf(stdout,\"  NFSFT = yes\\n\");\n      fscanf(stdin,\"nfft=%d\\n\",&use_nfft);\n      fprintf(stdout,\"  NFFT = %d\\n\",use_nfft);\n\t\t \tif (use_nfft != NO)\n      {\n        fprintf(stdout,\"  NFFT = yes\\n\");\n        fscanf(stdin,\"cutoff=%d\\n\",&cutoff);\n        fprintf(stdout,\"  Cutoff = %d\\n\",cutoff);\n\t\t\t   }\n      else\n      {\n        fprintf(stdout,\"  NFFT = no\\n\");\n        cutoff = 3;\n      }     \n        fscanf(stdin,\"threshold=%lf\\n\",&threshold);\n        fprintf(stdout,\"  Threshold = %E\\n\",threshold);\n  \t}\n\t  else\n\t  {\n      cutoff = 3;\n\t\t\tthreshold = 1000000000000.0;\n      fprintf(stdout,\"  NFSFT = no\\n\");\n\t  }\n\n    /* Initialize bandwidth bound. */\n    m_max = 0;\n    /* Initialize source node bound. */\n    l_max = 0;\n    /* Initialize target node bound. */\n    d_max = 0;\n\t\tld_max_prec = 0; \n\t\tl_max_prec = 0; \n    \n    /* Read kernel type. One of KT_ABEL_POISSON, KT_SINGULARITY, KT_LOC_SUPP \n     * or KT_GAUSSIAN. */\n    fscanf(stdin,\"kernel=%d\\n\",&kt);\n\n    fprintf(stdout,\"  Kernel type: %d\\n\",kt);    \n    \n    fscanf(stdin,\"parameter_sets=%d\\n\",&ip_max);\n    p = (double**) malloc(ip_max*sizeof(double*));\n\n    fprintf(stdout,\"  Parameter sets: %d\\n\",ip_max);    \n    \n    switch (kt)\n    {\n      case KT_ABEL_POISSON:\n      case KT_SINGULARITY:\n        for (ip = 0; ip < ip_max; ip++)\n        {  \n          p[ip] = (double*) malloc(1*sizeof(double));\n          fscanf(stdin,\"h=%lf\\n\",&p[ip][0]);\n          fprintf(stdout,\"    h = %lf\\n\",p[ip][0]);    \n        }\n\t\t\t  break;\n      case KT_GAUSSIAN:\n        for (ip = 0; ip < ip_max; ip++)\n        {  \n          p[ip] = (double*) malloc(1*sizeof(double));\n          fscanf(stdin,\"sigma=%lf\\n\",&p[ip][0]);\n          fprintf(stdout,\"    sigma = %lf\\n\",p[ip][0]);    \n        }\n        break;\n      case KT_LOC_SUPP:\n        for (ip = 0; ip < ip_max; ip++)\n        {  \n          p[ip] = (double*) malloc(2*sizeof(double));\n          fscanf(stdin,\"h=%lf \",&p[ip][0]);\n          fscanf(stdin,\"lambda=%lf\\n\",&p[ip][1]);\n          fprintf(stdout,\"    h = %lf, lambda = %lf\\n\",p[ip][0],p[ip][1]);    \n        }\n        break;\n    };\n    \n    /* Read number of bandwidths. */\n    fscanf(stdin,\"bandwidths=%d\\n\",&im_max);\n    m = (int*) malloc(im_max*sizeof(int));\n\n    fprintf(stdout,\"  Bandwidths: %d\\n\",im_max);    \n    \n    /* Read bandwidths. */\n    for (im = 0; im < im_max; im++)\n    {  \n      fscanf(stdin,\"M=%d\\n\",&m[im]);\n      m_max = max(m_max,m[im]);\n      fprintf(stdout,\"    M = %d\\n\",m[im]);    \n    }\n    \n    /* Read number of nodes specifications. */\n    fscanf(stdin,\"node_sets=%d\\n\",&ild_max);\n    ld = (int**) malloc(ild_max*sizeof(int*));\n    \n    fprintf(stdout,\"  Nodes: %d\\n\",ild_max);    \n\n  \tld_max_prec = 0;\n  \tl_max_prec = 0;\n    for (ild = 0; ild < ild_max; ild++)\n    {  \n      ld[ild] = (int*) malloc(5*sizeof(int));\n      fscanf(stdin,\"L=%d \",&ld[ild][0]);\n      l_max = max(l_max,ld[ild][0]);\n      fscanf(stdin,\"D=%d \",&ld[ild][1]);\n      d_max = max(d_max,ld[ild][1]);\n      fscanf(stdin,\"compare=%d \",&ld[ild][2]);\n      fprintf(stdout,\"    L = %d, D = %d, compare = %d\",ld[ild][0],ld[ild][1],ld[ild][2]);    \n\t\t\tif (ld[ild][2] == YES)\n\t\t\t{\n        fscanf(stdin,\"precomputed=%d\\n\",&ld[ild][3]);\n        fscanf(stdin,\"repetitions=%d\\n\",&ld[ild][4]);\n        fprintf(stdout,\", precomputed = %d, %repetitions = %d\",ld[ild][3],ld[ild][4]);    \n  \t\t\tif (ld[ild][3] == YES)\n        {\n\t\t\t\t  ld_max_prec = max(ld_max_prec,ld[ild][0]*ld[ild][1]);\n\t\t\t\t  l_max_prec = max(l_max_prec,ld[ild][0]);\n\t\t\t    precompute = YES;\n\t\t\t  }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t  ld[ild][4] = 1;\n\t\t\t}\n\t\t\tfprintf(stdout,\"\\n\");\n    }\n    \n    fprintf(stdout,\"  Maximum M = %d\\n\",m_max);    \n    fprintf(stdout,\"  Maximum L = %d\\n\",l_max);    \n    fprintf(stdout,\"  Maximum D = %d\\n\",d_max);    \n    \n    n_max = 1<<ngpt(m_max);\t\n\n    /** Allocate data structures. */\n    b = (complex*) malloc(l_max*sizeof(complex));\n    nu = (double*) malloc(2*l_max*sizeof(double));\n    f_hat = (complex**) malloc((2*m_max+1)*sizeof(complex*));\n    for (n = -m_max; n <= m_max; n++)\n    {\n      f_hat[n+m_max] = (complex*) malloc((n_max+1)*sizeof(complex));\n    }  \n    a = (complex*) malloc((m_max+1)*sizeof(complex));\n    xi = (double*) malloc(2*d_max*sizeof(double));\n    f_m = (complex*) malloc(d_max*sizeof(complex));\n    f = (complex*) malloc(d_max*sizeof(complex));\n    if (precompute == YES)\n\t\t{\n  \t\tfprintf(stderr,\"reached! %d\\n\",ld_max_prec);\n\t  \tfflush(stderr);\n\t\t  prec = (complex*) malloc(ld_max_prec*sizeof(complex));\n\t\t}\n    \n\t\t\n    /* Generate random source nodes and weights. */\n    for (l = 0; l < l_max; l++)\n    {\n      b[l] = /*1.0;*/drand48() - 0.5;\n      nu[2*l] = /*0.0;*/drand48() - 0.5;\n      nu[2*l+1] = /*0.25;*/0.5*drand48();\n      /*b[l] = 1.0;\n      nu[2*l] = 0.0;\n      nu[2*l+1] = 0.25;*/\n    }\n    \n    /* Generate random target nodes. */\n    for (d = 0; d < d_max; d++)\n    {\n      xi[2*d] = /*(d/(double)d_max)-0.5;*/drand48() - 0.5;\n      xi[2*d+1] = /*0.25;*/0.5*drand48();\n      /*xi[2*d] = (d/(double)d_max)-0.5;\n      xi[2*d+1] = 0.25;*/\n    }\n\n    sprintf(filename_tex,\"testcase%d.tex\",tc);\n    sprintf(filename_dat,\"testcase%d.dat\",tc);\n    file_tex = fopen(filename_tex,\"w\");\n    file_dat = fopen(filename_dat,\"w\");\n    fprintf(file_dat,\"kernel=%d\\n\",kt);\n    fprintf(file_dat,\"nfsft=%d\\n\",use_nfsft);\n\t\tif (use_nfsft != NO)\n\t\t{\n      fprintf(file_dat,\"nfft=%d\\n\",use_nfsft);\n      fprintf(file_dat,\"cutoff=%d\\n\",cutoff);\n      fprintf(file_dat,\"threshold=%lf\\n\",threshold);\n\t\t}\n    fprintf(file_tex,\"\\\\begin{tabular}{l|l|l|l|l|l|l|l}\\n\");\n    fprintf(file_tex,\"$L$ & $D$ & direct algorithm & with precomputation & fast summation, NDSFT & fast summation, NFSFT & error $E_{\\\\infty}$\\\\\\\\\\\\hline\\n\");\n    fclose(file_tex);\n\t\tfclose(file_dat);\n    \n    nfsft_precompute(m_max,threshold,0U);\n    \n    for (ip = 0; ip < ip_max; ip++)\n    {\n      fprintf(stdout,\"  Parameter set %d: \",ip);\n      switch (kt)\n      {\n        case KT_ABEL_POISSON:\n          fprintf(stdout,\" h = %lf\\n\",p[ip][0]);\n          break;\n        case KT_SINGULARITY:\n          fprintf(stdout,\" h = %lf\\n\",p[ip][0]);\n          break;\n        case KT_LOC_SUPP:\n          fprintf(stdout,\" h = %lf, lambda = %lf\\n\",p[ip][0],p[ip][1]);\n          break;\n        case KT_GAUSSIAN:\n          fprintf(stdout,\" rho = %lf\\n\",p[ip][0]);\n          break;\n      }          \n      \n      /* Kernel coeffcients up to m_max */\n\t\t\tswitch (kt)\n\t\t\t{\n\t\t\t\tcase KT_ABEL_POISSON:\n\t\t\t\t\tfor (k = 0; k <= m_max; k++)\n\t\t\t\t\t{        \n\t\t\t\t\t\ta[k] = SYMBOL_ABEL_POISSON(k,p[ip][0]);            \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KT_SINGULARITY:\n\t\t\t\t\tfor (k = 0; k <= m_max; k++)\n\t\t\t\t\t{        \n\t\t\t\t\t\ta[k] = SYMBOL_SINGULARITY(k,p[ip][0]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KT_LOC_SUPP:\n\t\t\t\t\tfor (k = 0; k <= m_max; k++)\n\t\t\t\t\t{        \n\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k] = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (k == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k] = ((p[ip][1]+1+p[ip][0])/(p[ip][1]+2.0))*a[k-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k] = (1.0/(k+p[ip][1]+1))*((2*k-1)*p[ip][0]*a[k-1] - (k-p[ip][1]-2)*a[k-2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;                \n\t\t\t\tcase KT_GAUSSIAN:\n          sprintf(filename_gaussian,\"gaussian%.0f.dat\",p[ip][0]);\n\t\t\t\t\tfprintf(stderr,\"filename = %s\\n\",filename_gaussian);\n          file_gaussian = fopen(filename_gaussian,\"r\");\n\t\t\t\t  if (file_gaussian != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t  fscanf(file_gaussian,\"%d\\n\",&nsymbols);\n\t\t\t\t\t\tfor (k = 0; k <= min(nsymbols,m_max); k++)\n\t\t\t\t\t\t{\n  \t\t\t\t\t  fscanf(file_gaussian,\"%lf\\n\",&a[k]);\n  \t\t\t\t\t  fprintf(stderr,\"a[%d] = %E\\n\",k,a[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k = nsymbols+1; k <= m_max; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  a[k] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  fprintf(stderr,\"Couldn't open file %s for reading!\\n\",filename_gaussian);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;                \n\t\t\t}\n\t\t\t\n      for (k = 0; k <= m_max; k++)\n      {\n        a[k] *= (2*k+1)/(4*PI);\n      }\n      \n      for (ild = 0; ild < ild_max; ild++)\n      {               \n        fprintf(stdout,\"    L = %d, D = %d, ld_max_prec = %d, l_max_prec = %d\\n\",ld[ild][0],ld[ild][1],ld_max_prec,l_max_prec);\n        if (ld[ild][2] != NO)\n        {\n\t\t\t\t  /* Check if direct algorithm with precomputation should be tested. */\n  \t\t\t\tif (ld[ild][3] != NO)\n\t  \t\t\t{ \n  \t\t\t\t\tt_dp = 0.0;\n\t\t\t\t\t  for (i = 0; i < ld[ild][4]; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tptr = prec;\n\t\t\t\t\t\t\trinc = l_max_prec-ld[ild][0];\n\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\tswitch (kt)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcase KT_ABEL_POISSON:\n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = poissonKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase KT_SINGULARITY:\n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = singularityKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase KT_LOC_SUPP:\n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = locSuppKernel(temp,p[ip][0],p[ip][1]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t\t\t\tcase KT_GAUSSIAN:\t              \n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = gaussianKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tptr += rinc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tptr = prec;\n\t\t\t\t\t\t\trinc = l_max_prec-ld[ild][0];\n\t\t\t\t\t\t\tif (kt == KT_LOC_SUPP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconstant = ((p[ip][1]+1)/(2*PI*pow(1-p[ip][0],p[ip][1]+1)));\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*(*ptr++);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tf[d] *= constant;\n\t\t\t\t\t\t\t\t\tptr += rinc;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt_dp += second() - t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*(*ptr++);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tptr += rinc;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt_dp += second() - t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt_dp = t_dp/((double)ld[ild][4]);\n\t\t\t\t\t\tprintf(\"t_dp = %f\\n\",t_dp);\n\t\t  \t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  t_dp = -1.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tt_d = 0.0;\n          for (i = 0; i < ld[ild][4]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (kt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase KT_ABEL_POISSON:\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*poissonKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d += second() - t;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase KT_SINGULARITY:\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*singularityKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d += second() - t;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase KT_LOC_SUPP:\n\t\t\t\t\t\t\t\tconstant = ((p[ip][1]+1)/(2*PI*pow(1-p[ip][0],p[ip][1]+1)));\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*locSuppKernel(temp,p[ip][0],p[ip][1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tf[d] *= constant;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d += second() - t;\n\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\tcase KT_GAUSSIAN:\t              \n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*gaussianKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d = second() - t;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}  \n\t\t\t\t\t}\n\t\t\t\t\tt_d = t_d/((double)ld[ild][4]);\n  \t\t\t\tprintf(\"t_d = %f\\n\",t_d);\n        }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t  t_d = -1.0;\n\t\t\t\t\tt_dp = -1.0;\n\t\t\t\t}\n        \n        \n        for (im = 0; im < im_max; im++)\n        {\n          fprintf(stderr,\"      M = %d:\\n \",m[im]);\n          \n          /* Init transform plans. */\n          plan_adjoint = nfsft_init_guru(m[im],ld[ild][0],f_hat,nu,b,(use_nfft!=0)?(0U):(NFSFT_USE_NDFT),cutoff);\n          plan = nfsft_init_guru(m[im],ld[ild][1],f_hat,xi,f_m,(use_nfft!=0)?(0U):(NFSFT_USE_NDFT),cutoff);\n          \n\t\t\t\t\tif (use_nfsft == BOTH)\n\t\t\t\t\t{\n  \t\t\t\t\tt_fd = 0.0;\n            for (i = 0; i < ld[ild][4]; i++)\n\t\t  \t\t\t{\n\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\tndsft_adjoint(plan_adjoint);\n\t\t\t\t\t\t\t/* Multiplication with diagonal matrix. */\n\t\t\t\t\t\t\tfor (k = 0; k <= m[im]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (n = -k; n <= k; n++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf_hat[n+m[im]][k] *= a[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tndsft_trafo(plan);\n\t\t\t\t\t\t\tt_fd += second() - t;\n\t\t\t\t\t\t}\n  \t\t\t\t\tt_fd = t_fd/((double)ld[ild][4]);\n\t\t\t\t\t\tprintf(\"t_fd = %f\\n\",t_fd);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  t_fd = -1.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tt_f = 0.0;\n          for (i = 0; i < ld[ild][4]; i++)\n    \t\t\t{\n\t\t\t\t\t\t/* Adjoint transform */\n\t\t\t\t\t\tt = second();\n\t\t\t\t\t\tif (use_nfsft != NO)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnfsft_adjoint(plan_adjoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tndsft_adjoint(plan_adjoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t/* Multiplication with diagonal matrix. */\n\t\t\t\t\t\tfor (k = 0; k <= m[im]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (n = -k; n <= k; n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tf_hat[n+m[im]][k] *= a[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t/* Forward transform */\n\t\t\t\t\t\tif (use_nfsft != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnfsft_trafo(plan);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tndsft_trafo(plan);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt_f += second() - t;\n\t\t\t\t\t}\n \t\t\t\t\tt_f = t_f/((double)ld[ild][4]);\n\t\t\t\t\tprintf(\"t_f = %f\\n\",t_f);\n\n          /* Finalize plans */\n          nfsft_finalize(plan_adjoint);\n          nfsft_finalize(plan);\n            \n          /*for (d = 0; d < ld[ild][1]; d++)\n          {\n            fprintf(stderr,\"%+5.16f, %+5.16f, %+.3E\\n\",creal(f_m[d]),creal(f[d]),creal(f_m[d]-f[d]));\n            fflush(stderr);\n          }*/\n\t\t\t\t\t/*fprintf(stderr,\"\\n\");\n          for (l = 0; l < ld[ild][0]; l++)\n          {\n            fprintf(stderr,\"%+5.16f\\n\",creal(b[l]));\n            fflush(stderr);\n          }*/\n\t\t\t\t\t\n\t\t\t\t\tif (ld[ild][2] != NO)\n\t\t\t\t\t{\n            err = error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]);\n  \t\t\t\t\tfprintf(stderr,\"err = %E\\n\",error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  err = -1.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t        //fprintf(stderr,\"||b||_1 = %E, L = %d\\n\",norm_complex_1(b,ld[ild][0]),ld[ild][0]);\n\n          file_tex = fopen(filename_tex,\"a\");\n          file_dat = fopen(filename_dat,\"a\");\n          \n          fprintf(file_tex,\"%6d & %6d & %.1E & %.1E & %.1E & %.1E & %.1E\\\\\\\\\\n\",ld[ild][0],ld[ild][1],t_d,t_dp,t_fd,t_f,error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n          if (ld[ild][2] != 0)\n          {\n            if (kt == KT_ABEL_POISSON || kt == KT_SINGULARITY || kt == KT_GAUSSIAN)\n            {\n              fprintf(file_dat,\"%.2f %3d %6d %6d %5.2f %5.2f %.4E\\n\",p[ip][0],m[im],ld[ild][0],ld[ild][1],t_d,t_f,error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n            }\n            else if (kt == KT_LOC_SUPP)\n            {\n              fprintf(file_dat,\"%.2f %2f %3d %6d %6d %5.2f %5.2f %.4E\\n\",p[ip][0],p[ip][1],m[im],ld[ild][0],ld[ild][1],t_d,t_f,error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n            }\n          }\n          else\n          {\n            if (kt == KT_ABEL_POISSON || kt == KT_SINGULARITY || kt == KT_GAUSSIAN)\n            {\n              fprintf(file_dat,\"%.2f %3d %6d %6d -1.0 %5.2f -1E0\\n\",p[ip][0],m[im],ld[ild][0],ld[ild][1],t_f);\n            }\n            else if (kt == KT_LOC_SUPP)\n            {\n              fprintf(file_dat,\"%.2f %2f %3d %6d %6d -1.0 %5.2f -1E0 -1E0\\n\",p[ip][0],p[ip][1],m[im],ld[ild][0],ld[ild][1],t_f);\n            }\n          }\n  \t\t    fclose(file_tex);\n\t      \tfclose(file_dat);\n        }\n      }\n      fprintf(file_tex,\"\\\\hline\\n\");\n    }\n    \n    file_tex = fopen(filename_tex,\"a\");\n    file_dat = fopen(filename_dat,\"a\");\n    fprintf(file_tex,\"\\\\end{tabular}\\n\");\n    fclose(file_tex);\n    fclose(file_dat);\n    \n    nfsft_forget();\n    \n    if (precompute == YES)\n\t\t{\n\t\t  free(prec);\n\t\t}\n    free(f);\n    free(f_m);\n    free(xi);\n    free(nu);\n    free(a);\n    for (n = -m_max; n <= m_max; n++)\n    {\n      free(f_hat[n+m_max]);\n    }   \n    free(f_hat);\n    free(b);\n    \n    for (ild = 0; ild < ild_max; ild++)\n    {\n      free(ld[ild]);\n    }  \n    free(ld);\n    \n    free(m);\n\n    for (ip = 0; ip < ip_max; ip++)\n    {\n      free(p[ip]);\n    }  \n    free(p);\n    \n    fprintf(stdout,\"\\n\");\n  }  \n  \n  return EXIT_SUCCESS;\n}\n";
		rLen = 20514;
		rLoc = 861;
		rType = 0;
		vrLen = 412;
		vrLoc = 20963;
	};
	4ED469FF0890F17700F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 47";
		rLen = 0;
		rLoc = 1218;
		rType = 0;
		vrLen = 543;
		vrLoc = 1031;
	};
	4ED46A000890F17700F4E929 = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "accuracy.c: 436";
		rLen = 0;
		rLoc = 11378;
		rType = 0;
		vrLen = 668;
		vrLoc = 11028;
	};
	4ED46A010890F17700F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 47";
		rLen = 0;
		rLoc = 1218;
		rType = 0;
		vrLen = 556;
		vrLoc = 1031;
	};
	4ED46A020890F17700F4E929 = {
		fRef = 4E5470A208329F8600CA0375;
		isa = PBXTextBookmark;
		name = "#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#else\n#  error Need config.h\n#endif\n\n/* Auxilliary headers */\n#include <complex.h>\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n/* Library headers. */\n#include \"nfsft.h\"\n#include \"util.h\"\n#include \"../../nfft/utils.h\"\n\n/** The symbol of the Abel-Poisson kernel */\n#define SYMBOL_ABEL_POISSON(k,h) pow(h,k)\n/** The symbol of the singularity kernel */\n#define SYMBOL_SINGULARITY(k,h) (2.0/(2*k+1))*pow(h,k)\n\n/* Kernel types */\n/** Abel-Poisson kernel */\n#define KT_ABEL_POISSON (0)\n/** Singularity kernel */\n#define KT_SINGULARITY  (1)\n/** Locally supported kernel */\n#define KT_LOC_SUPP     (2)\n/** Gaussian kernel */\n#define KT_GAUSSIAN     (3)\n\n#define NO   (0)\n#define YES  (1)\n#define BOTH (2)\n\n/** Computes the inner product on \\f$\\mathbb{S}^2\\f$. */\ninline double innerProduct(const double phi1, const double theta1, \n                           const double phi2, const double theta2)\n{\n  return cos(theta1)*cos(theta2) + sin(theta1)*sin(theta2)*cos(phi1-phi2);\n}\n\n/** Evaluates the Poisson kernel. */\ninline double poissonKernel(const double x, const double h)\n{\n \treturn (1.0/(4*PI))*(1-h*h)/pow(sqrt(1-2*h*x+h*h),3);\n}\n\n/** Evaluates the singularity kernel. */\ninline double singularityKernel(const double x, const double h)\n{\n  return (1.0/(2*PI))/sqrt(1-2*h*x+h*h);\n}\n\n/** Evaluates the locally supported kernel. */\ninline double locSuppKernel(const double x, const double h, const double lambda)\n{\n \treturn (x<=h)?(0.0):(pow((x-h),lambda));\n}\n\n/** Evaluates the Gaussian kernel. */\ninline double gaussianKernel(const double x, const double rho)\n{\n \treturn exp(rho*(x-1));\n}\n\n/**\n * The main program.\n *\n * \\param argc The number of arguments\n * \\param argv An array containing the arguments as C-strings\n *\n * \\return Exit code \n */\nint main (int argc, char **argv)\n{  \n  /** An array containing the parameter sets for the current kernel. */\n  double **p;\n  /** An array containing the parameters \\f$M\\f$. */\n  int *m;\n  /** An array containing the parameters \\f$L\\f$ and \\f$D\\f$. */\n  int **ld;\n  /** Index variable for p */\n  int ip;\n  /** Index variable for m */\n  int im;\n  /** Index variable for l */\n  int ild;\n  /** Maximum index for p */\n  int ip_max;\n  /** Maximum index for m */\n  int im_max;\n  /** Maximum index for l */\n  int ild_max;\n\n  /** Number of testcases */\n  int tc_max;\n  /** Maximum \\f$M\\f$ for the current dataset */\n  int m_max;\n  /** Maximum \\f$L\\f$ for the current dataset */\n  int l_max;\n  /** Maximum \\f$D\\f$ for the current dataset */\n  int d_max;\n\tlong ld_max_prec;\n\tlong l_max_prec;\n  \n  /** Index variable for testcases. */\n  int tc;\n  /** The kernel type */\n  int kt;\n  int cutoff;\n  double threshold;\n  \n  /** Next greater power of two with respect to m_max */\n  int n_max;\n \t/** \n   * The relative error\n   * \n   * \\f[\n       \\frac{\\left\\|f-f_M\\right\\|_{\\infty}}{\\left\\|\\mathbf{b}\\right\\|}\n   * \\f]\n   */\n  double t_d, t_dp, t_fd, t_f;\n  double nfactor;\n  double temp;\n\tdouble err;\n\tdouble t;\n\tint precompute = NO;\n\tcomplex *ptr;\n\t\n  /** Weights \\f$\\left(b_l\\right)_{l=0}^{L-1}\\f$ */\n \tcomplex *b;\n  /** Fourier coefficients */\n  complex **f_hat;\n  /** Symbool coefficients */\n \tcomplex *a;\n  /** Target nodes */\n \tdouble *xi;\n  /** Source nodes */\n \tdouble *nu;\n  /** Approximate function values */\n \tcomplex *f_m;\n  /** Exact function values */\n  complex *f;\n  complex *prec;\n  /** NFSFT plan */\n \tnfsft_plan plan;\n  /** adjoint NFSFT plan */\n  nfsft_plan plan_adjoint;\n  \n \tint i,j,k,n,d,l,use_nfsft,use_nfft,nsymbols;\n\tlong index;\n\tint rinc;\n  \n  FILE *file_tex;\n  FILE *file_dat;\n  FILE *file_gaussian;\n  char filename_tex[100];\n  char filename_dat[100];\n  char filename_gaussian[100];\n\tdouble constant;\n\t \t\n  /* Read number of testcases. */\n  fscanf(stdin,\"testcases=%d\\n\",&tc_max);\n  \n  fprintf(stdout,\"Number of testcases: %d\\n\\n\",tc_max);\n  \n  /* Process testcases. */\n  for (tc = 0; tc < tc_max; tc++)\n  {\n    fprintf(stdout,\"Testcase %d:\\n\",tc);\n\n    fscanf(stdin,\"nfsft=%d\\n\",&use_nfsft);\n    if (use_nfsft != NO)\n  \t{\n      fprintf(stdout,\"  NFSFT = yes\\n\");\n      fscanf(stdin,\"nfft=%d\\n\",&use_nfft);\n      fprintf(stdout,\"  NFFT = %d\\n\",use_nfft);\n\t\t \tif (use_nfft != NO)\n      {\n        fprintf(stdout,\"  NFFT = yes\\n\");\n        fscanf(stdin,\"cutoff=%d\\n\",&cutoff);\n        fprintf(stdout,\"  Cutoff = %d\\n\",cutoff);\n\t\t\t   }\n      else\n      {\n        fprintf(stdout,\"  NFFT = no\\n\");\n        cutoff = 3;\n      }     \n        fscanf(stdin,\"threshold=%lf\\n\",&threshold);\n        fprintf(stdout,\"  Threshold = %E\\n\",threshold);\n  \t}\n\t  else\n\t  {\n      cutoff = 3;\n\t\t\tthreshold = 1000000000000.0;\n      fprintf(stdout,\"  NFSFT = no\\n\");\n\t  }\n\n    /* Initialize bandwidth bound. */\n    m_max = 0;\n    /* Initialize source node bound. */\n    l_max = 0;\n    /* Initialize target node bound. */\n    d_max = 0;\n\t\tld_max_prec = 0; \n\t\tl_max_prec = 0; \n    \n    /* Read kernel type. One of KT_ABEL_POISSON, KT_SINGULARITY, KT_LOC_SUPP \n     * or KT_GAUSSIAN. */\n    fscanf(stdin,\"kernel=%d\\n\",&kt);\n\n    fprintf(stdout,\"  Kernel type: %d\\n\",kt);    \n    \n    fscanf(stdin,\"parameter_sets=%d\\n\",&ip_max);\n    p = (double**) malloc(ip_max*sizeof(double*));\n\n    fprintf(stdout,\"  Parameter sets: %d\\n\",ip_max);    \n    \n    switch (kt)\n    {\n      case KT_ABEL_POISSON:\n      case KT_SINGULARITY:\n        for (ip = 0; ip < ip_max; ip++)\n        {  \n          p[ip] = (double*) malloc(1*sizeof(double));\n          fscanf(stdin,\"h=%lf\\n\",&p[ip][0]);\n          fprintf(stdout,\"    h = %lf\\n\",p[ip][0]);    \n        }\n\t\t\t  break;\n      case KT_GAUSSIAN:\n        for (ip = 0; ip < ip_max; ip++)\n        {  \n          p[ip] = (double*) malloc(1*sizeof(double));\n          fscanf(stdin,\"sigma=%lf\\n\",&p[ip][0]);\n          fprintf(stdout,\"    sigma = %lf\\n\",p[ip][0]);    \n        }\n        break;\n      case KT_LOC_SUPP:\n        for (ip = 0; ip < ip_max; ip++)\n        {  \n          p[ip] = (double*) malloc(2*sizeof(double));\n          fscanf(stdin,\"h=%lf \",&p[ip][0]);\n          fscanf(stdin,\"lambda=%lf\\n\",&p[ip][1]);\n          fprintf(stdout,\"    h = %lf, lambda = %lf\\n\",p[ip][0],p[ip][1]);    \n        }\n        break;\n    };\n    \n    /* Read number of bandwidths. */\n    fscanf(stdin,\"bandwidths=%d\\n\",&im_max);\n    m = (int*) malloc(im_max*sizeof(int));\n\n    fprintf(stdout,\"  Bandwidths: %d\\n\",im_max);    \n    \n    /* Read bandwidths. */\n    for (im = 0; im < im_max; im++)\n    {  \n      fscanf(stdin,\"M=%d\\n\",&m[im]);\n      m_max = max(m_max,m[im]);\n      fprintf(stdout,\"    M = %d\\n\",m[im]);    \n    }\n    \n    /* Read number of nodes specifications. */\n    fscanf(stdin,\"node_sets=%d\\n\",&ild_max);\n    ld = (int**) malloc(ild_max*sizeof(int*));\n    \n    fprintf(stdout,\"  Nodes: %d\\n\",ild_max);    \n\n  \tld_max_prec = 0;\n  \tl_max_prec = 0;\n    for (ild = 0; ild < ild_max; ild++)\n    {  \n      ld[ild] = (int*) malloc(5*sizeof(int));\n      fscanf(stdin,\"L=%d \",&ld[ild][0]);\n      l_max = max(l_max,ld[ild][0]);\n      fscanf(stdin,\"D=%d \",&ld[ild][1]);\n      d_max = max(d_max,ld[ild][1]);\n      fscanf(stdin,\"compare=%d \",&ld[ild][2]);\n      fprintf(stdout,\"    L = %d, D = %d, compare = %d\",ld[ild][0],ld[ild][1],ld[ild][2]);    \n\t\t\tif (ld[ild][2] == YES)\n\t\t\t{\n        fscanf(stdin,\"precomputed=%d\\n\",&ld[ild][3]);\n        fscanf(stdin,\"repetitions=%d\\n\",&ld[ild][4]);\n        fprintf(stdout,\", precomputed = %d, %repetitions = %d\",ld[ild][3],ld[ild][4]);    \n  \t\t\tif (ld[ild][3] == YES)\n        {\n\t\t\t\t  ld_max_prec = max(ld_max_prec,ld[ild][0]*ld[ild][1]);\n\t\t\t\t  l_max_prec = max(l_max_prec,ld[ild][0]);\n\t\t\t    precompute = YES;\n\t\t\t  }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t  ld[ild][4] = 1;\n\t\t\t}\n\t\t\tfprintf(stdout,\"\\n\");\n    }\n    \n    fprintf(stdout,\"  Maximum M = %d\\n\",m_max);    \n    fprintf(stdout,\"  Maximum L = %d\\n\",l_max);    \n    fprintf(stdout,\"  Maximum D = %d\\n\",d_max);    \n    \n    n_max = 1<<ngpt(m_max);\t\n\n    /** Allocate data structures. */\n    b = (complex*) malloc(l_max*sizeof(complex));\n    nu = (double*) malloc(2*l_max*sizeof(double));\n    f_hat = (complex**) malloc((2*m_max+1)*sizeof(complex*));\n    for (n = -m_max; n <= m_max; n++)\n    {\n      f_hat[n+m_max] = (complex*) malloc((n_max+1)*sizeof(complex));\n    }  \n    a = (complex*) malloc((m_max+1)*sizeof(complex));\n    xi = (double*) malloc(2*d_max*sizeof(double));\n    f_m = (complex*) malloc(d_max*sizeof(complex));\n    f = (complex*) malloc(d_max*sizeof(complex));\n    if (precompute == YES)\n\t\t{\n  \t\tfprintf(stderr,\"reached! %d\\n\",ld_max_prec);\n\t  \tfflush(stderr);\n\t\t  prec = (complex*) malloc(ld_max_prec*sizeof(complex));\n\t\t}\n    \n\t\t\n    /* Generate random source nodes and weights. */\n    for (l = 0; l < l_max; l++)\n    {\n      b[l] = /*1.0;*/drand48() - 0.5;\n      nu[2*l] = /*0.0;*/drand48() - 0.5;\n      nu[2*l+1] = /*0.25;*/0.5*drand48();\n      /*b[l] = 1.0;\n      nu[2*l] = 0.0;\n      nu[2*l+1] = 0.25;*/\n    }\n    \n    /* Generate random target nodes. */\n    for (d = 0; d < d_max; d++)\n    {\n      xi[2*d] = /*(d/(double)d_max)-0.5;*/drand48() - 0.5;\n      xi[2*d+1] = /*0.25;*/0.5*drand48();\n      /*xi[2*d] = (d/(double)d_max)-0.5;\n      xi[2*d+1] = 0.25;*/\n    }\n\n    sprintf(filename_tex,\"testcase%d.tex\",tc);\n    sprintf(filename_dat,\"testcase%d.dat\",tc);\n    file_tex = fopen(filename_tex,\"w\");\n    file_dat = fopen(filename_dat,\"w\");\n    fprintf(file_dat,\"kernel=%d\\n\",kt);\n    fprintf(file_dat,\"nfsft=%d\\n\",use_nfsft);\n\t\tif (use_nfsft != NO)\n\t\t{\n      fprintf(file_dat,\"nfft=%d\\n\",use_nfsft);\n      fprintf(file_dat,\"cutoff=%d\\n\",cutoff);\n      fprintf(file_dat,\"threshold=%lf\\n\",threshold);\n\t\t}\n    fprintf(file_tex,\"\\\\begin{tabular}{l|l|l|l|l|l|l|l}\\n\");\n    fprintf(file_tex,\"$L$ & $D$ & direct algorithm & with precomputation & fast summation, NDSFT & fast summation, NFSFT & error $E_{\\\\infty}$\\\\\\\\\\\\hline\\n\");\n    fclose(file_tex);\n\t\tfclose(file_dat);\n    \n    nfsft_precompute(m_max,threshold,0U);\n    \n    for (ip = 0; ip < ip_max; ip++)\n    {\n      fprintf(stdout,\"  Parameter set %d: \",ip);\n      switch (kt)\n      {\n        case KT_ABEL_POISSON:\n          fprintf(stdout,\" h = %lf\\n\",p[ip][0]);\n          break;\n        case KT_SINGULARITY:\n          fprintf(stdout,\" h = %lf\\n\",p[ip][0]);\n          break;\n        case KT_LOC_SUPP:\n          fprintf(stdout,\" h = %lf, lambda = %lf\\n\",p[ip][0],p[ip][1]);\n          break;\n        case KT_GAUSSIAN:\n          fprintf(stdout,\" rho = %lf\\n\",p[ip][0]);\n          break;\n      }          \n      \n      /* Kernel coeffcients up to m_max */\n\t\t\tswitch (kt)\n\t\t\t{\n\t\t\t\tcase KT_ABEL_POISSON:\n\t\t\t\t\tfor (k = 0; k <= m_max; k++)\n\t\t\t\t\t{        \n\t\t\t\t\t\ta[k] = SYMBOL_ABEL_POISSON(k,p[ip][0]);            \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KT_SINGULARITY:\n\t\t\t\t\tfor (k = 0; k <= m_max; k++)\n\t\t\t\t\t{        \n\t\t\t\t\t\ta[k] = SYMBOL_SINGULARITY(k,p[ip][0]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KT_LOC_SUPP:\n\t\t\t\t\tfor (k = 0; k <= m_max; k++)\n\t\t\t\t\t{        \n\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k] = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (k == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k] = ((p[ip][1]+1+p[ip][0])/(p[ip][1]+2.0))*a[k-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta[k] = (1.0/(k+p[ip][1]+1))*((2*k-1)*p[ip][0]*a[k-1] - (k-p[ip][1]-2)*a[k-2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;                \n\t\t\t\tcase KT_GAUSSIAN:\n          sprintf(filename_gaussian,\"gaussian%.0f.dat\",p[ip][0]);\n\t\t\t\t\tfprintf(stderr,\"filename = %s\\n\",filename_gaussian);\n          file_gaussian = fopen(filename_gaussian,\"r\");\n\t\t\t\t  if (file_gaussian != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t  fscanf(file_gaussian,\"%d\\n\",&nsymbols);\n\t\t\t\t\t\tfor (k = 0; k <= min(nsymbols,m_max); k++)\n\t\t\t\t\t\t{\n  \t\t\t\t\t  fscanf(file_gaussian,\"%lf\\n\",&a[k]);\n  \t\t\t\t\t  fprintf(stderr,\"a[%d] = %E\\n\",k,a[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k = nsymbols+1; k <= m_max; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  a[k] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  fprintf(stderr,\"Couldn't open file %s for reading!\\n\",filename_gaussian);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;                \n\t\t\t}\n\t\t\t\n      for (k = 0; k <= m_max; k++)\n      {\n        a[k] *= (2*k+1)/(4*PI);\n      }\n      \n      for (ild = 0; ild < ild_max; ild++)\n      {               \n        fprintf(stdout,\"    L = %d, D = %d, ld_max_prec = %d, l_max_prec = %d\\n\",ld[ild][0],ld[ild][1],ld_max_prec,l_max_prec);\n        if (ld[ild][2] != NO)\n        {\n\t\t\t\t  /* Check if direct algorithm with precomputation should be tested. */\n  \t\t\t\tif (ld[ild][3] != NO)\n\t  \t\t\t{ \n  \t\t\t\t\tt_dp = 0.0;\n\t\t\t\t\t  for (i = 0; i < ld[ild][4]; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tptr = prec;\n\t\t\t\t\t\t\trinc = l_max_prec-ld[ild][0];\n\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\tswitch (kt)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcase KT_ABEL_POISSON:\n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = poissonKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase KT_SINGULARITY:\n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = singularityKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase KT_LOC_SUPP:\n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = locSuppKernel(temp,p[ip][0],p[ip][1]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t\t\t\tcase KT_GAUSSIAN:\t              \n\t\t\t\t\t\t\t\t\t\t\t*ptr++ = gaussianKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tptr += rinc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tptr = prec;\n\t\t\t\t\t\t\trinc = l_max_prec-ld[ild][0];\n\t\t\t\t\t\t\tif (kt == KT_LOC_SUPP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconstant = ((p[ip][1]+1)/(2*PI*pow(1-p[ip][0],p[ip][1]+1)));\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*(*ptr++);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tf[d] *= constant;\n\t\t\t\t\t\t\t\t\tptr += rinc;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt_dp += second() - t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*(*ptr++);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tptr += rinc;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt_dp += second() - t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt_dp = t_dp/((double)ld[ild][4]);\n\t\t\t\t\t\tprintf(\"t_dp = %f\\n\",t_dp);\n\t\t  \t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  t_dp = -1.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tt_d = 0.0;\n          for (i = 0; i < ld[ild][4]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (kt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase KT_ABEL_POISSON:\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*poissonKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d += second() - t;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase KT_SINGULARITY:\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*singularityKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d += second() - t;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase KT_LOC_SUPP:\n\t\t\t\t\t\t\t\tconstant = ((p[ip][1]+1)/(2*PI*pow(1-p[ip][0],p[ip][1]+1)));\n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*locSuppKernel(temp,p[ip][0],p[ip][1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tf[d] *= constant;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d += second() - t;\n\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\tcase KT_GAUSSIAN:\t              \n\t\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\t\tfor (d = 0; d < ld[ild][1]; d++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf[d] = 0.0;\n\t\t\t\t\t\t\t\t\tfor (l = 0; l < ld[ild][0]; l++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp = innerProduct(2*PI*nu[2*l],2*PI*nu[2*l+1],2*PI*xi[2*d],2*PI*xi[2*d+1]);\n\t\t\t\t\t\t\t\t\t\tf[d] += b[l]*gaussianKernel(temp,p[ip][0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tt_d = second() - t;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}  \n\t\t\t\t\t}\n\t\t\t\t\tt_d = t_d/((double)ld[ild][4]);\n  \t\t\t\tprintf(\"t_d = %f\\n\",t_d);\n        }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t  t_d = -1.0;\n\t\t\t\t\tt_dp = -1.0;\n\t\t\t\t}\n        \n        \n        for (im = 0; im < im_max; im++)\n        {\n          fprintf(stderr,\"      M = %d:\\n \",m[im]);\n          \n          /* Init transform plans. */\n          plan_adjoint = nfsft_init_guru(m[im],ld[ild][0],f_hat,nu,b,(use_nfft!=0)?(0U):(NFSFT_USE_NDFT),cutoff);\n          plan = nfsft_init_guru(m[im],ld[ild][1],f_hat,xi,f_m,(use_nfft!=0)?(0U):(NFSFT_USE_NDFT),cutoff);\n          \n\t\t\t\t\tif (use_nfsft == BOTH)\n\t\t\t\t\t{\n  \t\t\t\t\tt_fd = 0.0;\n            for (i = 0; i < ld[ild][4]; i++)\n\t\t  \t\t\t{\n\t\t\t\t\t\t\tt = second();\n\t\t\t\t\t\t\tndsft_adjoint(plan_adjoint);\n\t\t\t\t\t\t\t/* Multiplication with diagonal matrix. */\n\t\t\t\t\t\t\tfor (k = 0; k <= m[im]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (n = -k; n <= k; n++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tf_hat[n+m[im]][k] *= a[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tndsft_trafo(plan);\n\t\t\t\t\t\t\tt_fd += second() - t;\n\t\t\t\t\t\t}\n  \t\t\t\t\tt_fd = t_fd/((double)ld[ild][4]);\n\t\t\t\t\t\tprintf(\"t_fd = %f\\n\",t_fd);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  t_fd = -1.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tt_f = 0.0;\n          for (i = 0; i < ld[ild][4]; i++)\n    \t\t\t{\n\t\t\t\t\t\t/* Adjoint transform */\n\t\t\t\t\t\tt = second();\n\t\t\t\t\t\tif (use_nfsft != NO)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnfsft_adjoint(plan_adjoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tndsft_adjoint(plan_adjoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t/* Multiplication with diagonal matrix. */\n\t\t\t\t\t\tfor (k = 0; k <= m[im]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (n = -k; n <= k; n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tf_hat[n+m[im]][k] *= a[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t/* Forward transform */\n\t\t\t\t\t\tif (use_nfsft != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnfsft_trafo(plan);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tndsft_trafo(plan);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt_f += second() - t;\n\t\t\t\t\t}\n \t\t\t\t\tt_f = t_f/((double)ld[ild][4]);\n\t\t\t\t\tprintf(\"t_f = %f\\n\",t_f);\n\n          /* Finalize plans */\n          nfsft_finalize(plan_adjoint);\n          nfsft_finalize(plan);\n            \n          /*for (d = 0; d < ld[ild][1]; d++)\n          {\n            fprintf(stderr,\"%+5.16f, %+5.16f, %+.3E\\n\",creal(f_m[d]),creal(f[d]),creal(f_m[d]-f[d]));\n            fflush(stderr);\n          }*/\n\t\t\t\t\t/*fprintf(stderr,\"\\n\");\n          for (l = 0; l < ld[ild][0]; l++)\n          {\n            fprintf(stderr,\"%+5.16f\\n\",creal(b[l]));\n            fflush(stderr);\n          }*/\n\t\t\t\t\t\n\t\t\t\t\tif (ld[ild][2] != NO)\n\t\t\t\t\t{\n            err = error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]);\n  \t\t\t\t\tfprintf(stderr,\"err = %E\\n\",error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  err = -1.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t        //fprintf(stderr,\"||b||_1 = %E, L = %d\\n\",norm_complex_1(b,ld[ild][0]),ld[ild][0]);\n\n          file_tex = fopen(filename_tex,\"a\");\n          file_dat = fopen(filename_dat,\"a\");\n          \n          fprintf(file_tex,\"%6d & %6d & %.1E & %.1E & %.1E & %.1E & %.1E\\\\\\\\\\n\",ld[ild][0],ld[ild][1],t_d,t_dp,t_fd,t_f,error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n          if (ld[ild][2] != 0)\n          {\n            if (kt == KT_ABEL_POISSON || kt == KT_SINGULARITY || kt == KT_GAUSSIAN)\n            {\n              fprintf(file_dat,\"%.2f %3d %6d %6d %5.2f %5.2f %.4E\\n\",p[ip][0],m[im],ld[ild][0],ld[ild][1],t_d,t_f,error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n            }\n            else if (kt == KT_LOC_SUPP)\n            {\n              fprintf(file_dat,\"%.2f %2f %3d %6d %6d %5.2f %5.2f %.4E\\n\",p[ip][0],p[ip][1],m[im],ld[ild][0],ld[ild][1],t_d,t_f,error_complex_inf(f, f_m, ld[ild][1])/norm_complex_1(b,ld[ild][0]));\n            }\n          }\n          else\n          {\n            if (kt == KT_ABEL_POISSON || kt == KT_SINGULARITY || kt == KT_GAUSSIAN)\n            {\n              fprintf(file_dat,\"%.2f %3d %6d %6d -1.0 %5.2f -1E0\\n\",p[ip][0],m[im],ld[ild][0],ld[ild][1],t_f);\n            }\n            else if (kt == KT_LOC_SUPP)\n            {\n              fprintf(file_dat,\"%.2f %2f %3d %6d %6d -1.0 %5.2f -1E0 -1E0\\n\",p[ip][0],p[ip][1],m[im],ld[ild][0],ld[ild][1],t_f);\n            }\n          }\n  \t\t    fclose(file_tex);\n\t      \tfclose(file_dat);\n        }\n      }\n      fprintf(file_tex,\"\\\\hline\\n\");\n    }\n    \n    file_tex = fopen(filename_tex,\"a\");\n    file_dat = fopen(filename_dat,\"a\");\n    fprintf(file_tex,\"\\\\end{tabular}\\n\");\n    fclose(file_tex);\n    fclose(file_dat);\n    \n    nfsft_forget();\n    \n    if (precompute == YES)\n\t\t{\n\t\t  free(prec);\n\t\t}\n    free(f);\n    free(f_m);\n    free(xi);\n    free(nu);\n    free(a);\n    for (n = -m_max; n <= m_max; n++)\n    {\n      free(f_hat[n+m_max]);\n    }   \n    free(f_hat);\n    free(b);\n    \n    for (ild = 0; ild < ild_max; ild++)\n    {\n      free(ld[ild]);\n    }  \n    free(ld);\n    \n    free(m);\n\n    for (ip = 0; ip < ip_max; ip++)\n    {\n      free(p[ip]);\n    }  \n    free(p);\n    \n    fprintf(stdout,\"\\n\");\n  }  \n  \n  return EXIT_SUCCESS;\n}\n";
		rLen = 20514;
		rLoc = 861;
		rType = 0;
		vrLen = 412;
		vrLoc = 20963;
	};
	4ED46A030890F17700F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 76";
		rLen = 0;
		rLoc = 1735;
		rType = 0;
		vrLen = 716;
		vrLoc = 1512;
	};
	4ED46A060890F62700F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 216";
		rLen = 0;
		rLoc = 5881;
		rType = 0;
		vrLen = 1015;
		vrLoc = 4663;
	};
	4ED46A070890F70500F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 205";
		rLen = 0;
		rLoc = 5077;
		rType = 0;
		vrLen = 984;
		vrLoc = 3786;
	};
	4ED46A080891060E00F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 238";
		rLen = 0;
		rLoc = 5889;
		rType = 0;
		vrLen = 824;
		vrLoc = 5576;
	};
	4ED46A090891084F00F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 238";
		rLen = 0;
		rLoc = 5889;
		rType = 0;
		vrLen = 824;
		vrLoc = 5576;
	};
	4ED46A0A089109C900F4E929 = {
		fRef = 4E6CD54C07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = copyc_hat;
		rLen = 9;
		rLoc = 3791;
		rType = 0;
		vrLen = 514;
		vrLoc = 3124;
	};
	4ED46A0B089109C900F4E929 = {
		fRef = 4E6E40C5082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "updatec_xpay(fftw_complex* x,double a, fftw_complex* y, int n)";
		rLen = 62;
		rLoc = 20652;
		rType = 0;
		vrLen = 567;
		vrLoc = 20379;
	};
	4ED46A0C089109C900F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 248";
		rLen = 0;
		rLoc = 6234;
		rType = 0;
		vrLen = 909;
		vrLoc = 5576;
	};
	4ED46A0D089109C900F4E929 = {
		fRef = 4E6E40C5082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = "updatec_xpay(fftw_complex* x,double a, fftw_complex* y, int n)";
		rLen = 62;
		rLoc = 20652;
		rType = 0;
		vrLen = 567;
		vrLoc = 20379;
	};
	4ED46A0E089109C900F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 249";
		rLen = 0;
		rLoc = 6257;
		rType = 0;
		vrLen = 874;
		vrLoc = 5576;
	};
	4ED46A0F08910A5900F4E929 = {
		fRef = 4E6CD54D07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "util.h: norm_complex_2";
		rLen = 0;
		rLoc = 954;
		rType = 0;
		vrLen = 1061;
		vrLoc = 15;
	};
	4ED46A1008910A5900F4E929 = {
		fRef = 4E6CD54C07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "double norm_complex_2(complex *x, int n)";
		rLen = 40;
		rLoc = 1552;
		rType = 0;
		vrLen = 380;
		vrLoc = 1531;
	};
	4ED46A1108910A5900F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 249";
		rLen = 0;
		rLoc = 6268;
		rType = 0;
		vrLen = 885;
		vrLoc = 5576;
	};
	4ED46A1208910A5900F4E929 = {
		fRef = 4E6CD54D07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "util.h: norm_complex_2";
		rLen = 0;
		rLoc = 954;
		rType = 0;
		vrLen = 1061;
		vrLoc = 15;
	};
	4ED46A1308910A5900F4E929 = {
		fRef = 4E6CD54C07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "double norm_complex_2(complex *x, int n)";
		rLen = 40;
		rLoc = 1552;
		rType = 0;
		vrLen = 380;
		vrLoc = 1531;
	};
	4ED46A1408910A5900F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 250";
		rLen = 0;
		rLoc = 6335;
		rType = 0;
		vrLen = 936;
		vrLoc = 5576;
	};
	4ED46A1508910C6700F4E929 = {
		fRef = 4E6CD54C07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "double norm_f_hat_1(complex **f_hat, int M)\n";
		rLen = 44;
		rLoc = 3182;
		rType = 0;
		vrLen = 470;
		vrLoc = 2981;
	};
	4ED46A1608910C6700F4E929 = {
		fRef = 4E6CD54D07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "util.h: norm_f_hat_1";
		rLen = 0;
		rLoc = 1000;
		rType = 0;
		vrLen = 1513;
		vrLoc = 304;
	};
	4ED46A1708910C6700F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 246";
		rLen = 0;
		rLoc = 6154;
		rType = 0;
		vrLen = 927;
		vrLoc = 5576;
	};
	4ED46A1808910C6700F4E929 = {
		fRef = 4E6CD54D07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "util.h: norm_f_hat_1";
		rLen = 0;
		rLoc = 1000;
		rType = 0;
		vrLen = 1513;
		vrLoc = 304;
	};
	4ED46A1908910C6700F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 249";
		rLen = 0;
		rLoc = 6256;
		rType = 0;
		vrLen = 959;
		vrLoc = 5883;
	};
	4ED46A1A08910EB500F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 117";
		rLen = 0;
		rLoc = 2497;
		rType = 0;
		vrLen = 577;
		vrLoc = 2082;
	};
	4ED46A1B08910ECA00F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 122";
		rLen = 0;
		rLoc = 2585;
		rType = 0;
		vrLen = 558;
		vrLoc = 2082;
	};
	4ED46A1C08910EDD00F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 101";
		rLen = 0;
		rLoc = 2209;
		rType = 0;
		vrLen = 569;
		vrLoc = 2072;
	};
	4ED46A1D08910F0000F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 252";
		rLen = 0;
		rLoc = 6348;
		rType = 0;
		vrLen = 922;
		vrLoc = 5836;
	};
	4ED46A1E08910F7400F4E929 = {
		fRef = 4ED46A1F08910F7400F4E929;
		isa = PBXTextBookmark;
		name = "(null): 70";
		rLen = 0;
		rLoc = 424;
		rType = 0;
		vrLen = 180;
		vrLoc = 244;
	};
	4ED46A1F08910F7400F4E929 = {
		isa = PBXFileReference;
		name = test.in;
		path = /Users/keiner/Temporary/trunk/obsolete/keiner/tests/accuracy2/test.in;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4ED46A2008910F7400F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 252";
		rLen = 0;
		rLoc = 6348;
		rType = 0;
		vrLen = 922;
		vrLoc = 5836;
	};
	4ED46A2108910F7400F4E929 = {
		fRef = 4ED46A2208910F7400F4E929;
		isa = PBXTextBookmark;
		name = "(null): 70";
		rLen = 0;
		rLoc = 424;
		rType = 0;
		vrLen = 180;
		vrLoc = 244;
	};
	4ED46A2208910F7400F4E929 = {
		isa = PBXFileReference;
		name = test.in;
		path = /Users/keiner/Temporary/trunk/obsolete/keiner/tests/accuracy2/test.in;
		refType = 0;
		sourceTree = "<absolute>";
	};
	4ED46A2308910F7400F4E929 = {
		fRef = 4ED469FC0890F0E100F4E929;
		isa = PBXTextBookmark;
		name = "accuracy2.c: 252";
		rLen = 0;
		rLoc = 6348;
		rType = 0;
		vrLen = 794;
		vrLoc = 2885;
	};
	4EDA6CF007A439F1008B1386 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {942, 1119}}";
			sepNavSelRange = "{518, 0}";
			sepNavVisRect = "{{0, 0}, {942, 423}}";
		};
	};
	4EDEC4EB07CE349A00514E5A = {
		fRef = 4EDA6CF007A439F1008B1386;
		isa = PBXTextBookmark;
		name = "main.1: 14";
		rLen = 0;
		rLoc = 518;
		rType = 0;
		vrLen = 957;
		vrLoc = 0;
	};
	4EE0558D086DA00D003A47E5 = {
		fRef = 4E294D5008575D3600F546C3;
		isa = PBXTextBookmark;
		name = "healpix.c: 163";
		rLen = 0;
		rLoc = 5261;
		rType = 0;
		vrLen = 673;
		vrLoc = 3676;
	};
	4EE0559B086DA10C003A47E5 = {
		fRef = 4E5470E10832A31200CA0375;
		isa = PBXTextBookmark;
		name = "flft.c: 317";
		rLen = 0;
		rLoc = 10209;
		rType = 0;
		vrLen = 810;
		vrLoc = 9165;
	};
	4EE055AD086DA4D6003A47E5 = {
		fRef = 4EAD69A2083BE07E00C61F13;
		isa = PBXTextBookmark;
		name = "  w = (double*) malloc((2*m_max+1)*sizeof(double));\n";
		rLen = 52;
		rLoc = 4404;
		rType = 0;
		vrLen = 704;
		vrLoc = 8368;
	};
	4EE055E4086DA894003A47E5 = {
		fRef = 4E293282082E501F004AD73C;
		isa = PBXTextBookmark;
		name = infsft_before_loop_help;
		rLen = 23;
		rLoc = 3305;
		rType = 0;
		vrLen = 1167;
		vrLoc = 5251;
	};
	4EE055EA086DA935003A47E5 = {
		fRef = 4E6E40C5082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = copyc_w;
		rLen = 7;
		rLoc = 20219;
		rType = 0;
		vrLen = 530;
		vrLoc = 19972;
	};
	4EE055EB086DA935003A47E5 = {
		fRef = 4E6EA365083E95C9004C5D07;
		isa = PBXTextBookmark;
		name = "inverse.c: 212";
		rLen = 0;
		rLoc = 5172;
		rType = 0;
		vrLen = 560;
		vrLoc = 4875;
	};
	4EE056E6086DE4EE003A47E5 = {
		fRef = 4E23D9390854D1E300CC656A;
		isa = PBXTextBookmark;
		name = "egm96.c: 170";
		rLen = 0;
		rLoc = 4052;
		rType = 0;
		vrLen = 721;
		vrLoc = 2930;
	};
	4EE659D4087F92A000926C77 = {
		fRef = 4E6CD54507C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "api.h: FIRST_L";
		rLen = 0;
		rLoc = 682;
		rType = 0;
		vrLen = 750;
		vrLoc = 318;
	};
	4EE65A2A087FA0F000926C77 = {
		fRef = 4E29331A082E672F004AD73C;
		isa = PBXTextBookmark;
		name = "wrapper.c: 186";
		rLen = 0;
		rLoc = 4412;
		rType = 0;
		vrLen = 898;
		vrLoc = 3811;
	};
	4EE9EBAF08786E2B00880508 = {
		fRef = 4E6E40C3082CB46F00642FF0;
		isa = PBXTextBookmark;
		name = nfft_init_1d;
		rLen = 12;
		rLoc = 6185;
		rType = 0;
		vrLen = 870;
		vrLoc = 5167;
	};
	4EE9EBB908786EE000880508 = {
		fRef = 4E6CD54B07C54A7E0040176B;
		isa = PBXTextBookmark;
		name = "nfsft.h: 68";
		rLen = 0;
		rLoc = 1670;
		rType = 0;
		vrLen = 676;
		vrLoc = 1014;
	};
	4EE9EBCD0878767600880508 = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {937, 4287}}";
			sepNavSelRange = "{1772, 0}";
			sepNavVisRect = "{{0, 784}, {910, 470}}";
		};
	};
	4EE9EBD20878768200880508 = {
		fRef = 4EE9EBCD0878767600880508;
		isa = PBXTextBookmark;
		name = "interpolation.c: 1";
		rLen = 0;
		rLoc = 0;
		rType = 0;
		vrLen = 920;
		vrLoc = 0;
	};
	4EE9EBD508787B6200880508 = {
		fRef = 4E02C48E082F816D00EC0863;
		isa = PBXTextBookmark;
		name = "convolution.c: 55";
		rLen = 0;
		rLoc = 1326;
		rType = 0;
		vrLen = 723;
		vrLoc = 1066;
	};
	8DD76F620486A84900D96B5E = {
		activeExec = 0;
		executables = (
			4EB20A1E07D4B30C00FD1AB8,
		);
	};
}
