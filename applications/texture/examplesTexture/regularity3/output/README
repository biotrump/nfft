Ralf hat mir ein Gitter h, r, Samples x_ref und ein Mathematika Notebook 
geschickt. (N1 = 7, N2 = 5159, N1*N2 = 36113)
Mit dem Notebook von Ralf habe ich omega_ref erzeugt. (Bandbreite 100)
Aus unerklärlichen Gründen passten omega_ref und x_ref auf dem Gitter h, r 
nicht zusammen.
Die Polfiguren waren "verdreht".
Deshalb habe ich in r die Winkel \phi (bzw. \rho, in Ralfs Notation) durch 
-\phi (bzw. -\rho) ersetzt.
Dann war der Fehler ||x_ref - x||_2 / ||x_ref||_2 ca. 1.04e-7, wobei x die 
samples sind, die die Texturtransformation auf Eingabe omega_ref, h und r 
erzeugt.

Nun zu meinen Berechnungen:

Mein Programm berechnete mit dem Solver zu x_ref die Frequenzen omega.
Um die mit omega_ref zu verglichen, habe ich die Punkte

(l, ||omega(l,.,.)-omega_ref(l,.,.)||_2 / ||omega_ref||_2)

geplottet.
Ich habe relativ zurückhaltend mit ||omega_ref||_2 normiert.
Man hätte auch ||omega_ref(l,.,.)||_2 nehmen können.

Zu den Parametern:

new_N ist die Bandbreite von omega.
In den Legenden der Plots habe ich einfachheitshalber N geschrieben.
new_N durchläuft 2, 4, 8, 16, 32, 64.
omega hat dann jeweils 35, 165, 969, 6545, 47905, 366145 Komponenten.
Die letzten beiden Rechnungen sollte man besser wegschmeißen, weil das LGS dort
unterbestimmt ist.

Damping Faktoren für den Solver: (1/n)
Die beschreibe ich am beste in Pseudocode:

i = 1;
for(l = 0; l <= N; l++)
for(n = -l; n <= l; n++)
for(m = -l; m <= l; m++)
{
if(l odd)
	w_hat[l,m,n] = 0;
else
	w_hat[l,m,n] = 1/i;
i++;
}

Ich setze die Faktoren für ungerades l auf 0, da Polfiguren immer gearde sind,
ich aber nur Samples von der oberen Hemisphere habe.
(Ich habe auch ausprobiert, was passiert, wenn man die Samples gerade fortsetzt.
Der Solver hat dann aber kein Frequenzen omega mit 
omega[l,m,n] = 0, falls l ungerade
gefunden.)
Da der Fehler ||omega_ref(l,.,.) - omega(l,.,.)||_2 = 0 für ungerade l,
habe ich die beim Plotten ausgelassen.
Die anderen Faktoren habe ich auf 1/i und nicht 1/i^2 oder 1/i^3 gesetzt, weil
im Fall new_n=8 der Solver bei diesen Faktoren am schnellsten konvergierte und 
das kleinste Residuum erzeugte.

Das Abbruchkriterium habe ich grob gesagt so gewählt, dass der Solver abbricht, 
wenn nichts mehr besser wird.
Genauer habe ich alle 10 Iterationen das alte und neue Residuum
res_min = min(res_min, res); res = ||x_ref - x||_2 / ||x_ref||_2
berechnet und verglichen.
Wenn 11 aufeinanderfolgende Male
(res_min - res) / res_min < 0.01
galt, dann habe ich abgebrochen.
