#include <stdio.h>
#include <complex.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include <nfft3_texture.h>
#include <texture_util.h>

/**
 * @defgroup texture_calculate_x Texture: Calculate x
 * This program calculates to a given grid and frequencies the samples x.
 *
 * @section CLA Command Line Arguments
 * -# The file containing the frequency vector. (default: omega)
 * -# The file containing the pole figures. (default: grid_h)
 * -# The file containing the nodes. (default: grid_r)
 * -# The property file. (default: propfile_x)
 *
 * @section PF Property File
 * The property file contains the grid type. (See @ref texture_utility)
 *
 * @section Inp Input
 * There is no user input.
 *
 * @section ProcOutp Processing and Output
 * The program calculates and writes the grid (grid type 0) or reades the grid 
 * from file (grid type 1).
 * It reades omega and then calculates the samples x.
 * The samples are printed to stdout.
 * 
 * @author Matthias Schmalz
 * @ingroup texture_examples
 */

int grid_type;
const char *grid_h_file;
const char *grid_r_file;

int N, h_theta_count, h_phi_count, r_theta_count, r_phi_count;
int N1, N2;
double _Complex *omega, *x;
double *h_phi, *h_theta, *r;

void init()
{
}

void read_properties(const char *propfile_name)
{
	FILE *f = fopen(propfile_name, "r");

	fscanf(f, "%d", &grid_type);
	fclose(f);
}

void read_params()
{
	if (grid_type == 0) {
		scanf("%d%d%d%d", &h_phi_count, &h_theta_count, &r_phi_count,
					&r_theta_count);
		printf("# h_phi_count: %d h_theta_count: %d\n", h_phi_count,
					 h_theta_count);
		printf("# r_phi_count: %d r_theta_count: %d\n", r_phi_count,
					 r_theta_count);
	}
	printf("#\n");
}

void calculate_x()
{
	texture_plan plan;

	x = (double _Complex *) smart_malloc(N1 * N2 * sizeof(double _Complex));

	texture_precompute(N);
	texture_init(&plan, N, N1, N2, omega, x, h_phi, h_theta, r);
	texture_trafo(&plan);
	texture_finalize(&plan);

	texture_forget();
}

void cleanup()
{
	free(omega);
	free(x);
	free(h_phi);
	free(h_theta);
	free(r);
}

void usage()
{
	fprintf(stderr, "Illegal parameters!");
}

int main(int argc, char *argv[])
{
	const char *omega_file = "omega";
	const char *propfile_name = "propfile_x";
	grid_h_file = "grid_h";
	grid_r_file = "grid_r";
	FILE *f, *g;

	if (argc > 1) {
		omega_file = argv[1];
	}
	if (argc > 2) {
		grid_h_file = argv[2];
	}
	if (argc > 3) {
		grid_r_file = argv[3];
	}
	if (argc > 4) {
		propfile_name = argv[4];
	}

	if (argc <= 5) {
		init();

		read_properties(propfile_name);

		printf("Samples\n");
		printf("# grid_type: %d (%s)\n", grid_type, grid_descr[grid_type]);

		read_params();

		f = fopen(omega_file, "r");
		read_omega(&N, &omega, f, stdout);
		fclose(f);

		switch (grid_type) {
			case 1:
			{
				f = fopen(grid_h_file, "r");
				g = fopen(grid_r_file, "r");
				read_grid(&N1, &N2, &h_phi, &h_theta, &r, f, g, stdout);
				fclose(f);
				fclose(g);
				break;
			}
			case 0:
			{
				grid_dim dims;

				N1 = h_phi_count * (h_theta_count - 2) + 2;
				N2 = r_phi_count * (r_theta_count - 2) + 2;

				h_phi = (double *) smart_malloc(N1 * sizeof(double));
				h_theta = (double *) smart_malloc(N2 * sizeof(double));
				r = (double *) smart_malloc(N1 * N2 * 2 * sizeof(double));

				dims.angles.h_phi_count = h_phi_count;
				dims.angles.h_theta_count = h_theta_count;
				dims.angles.r_phi_count = r_phi_count;
				dims.angles.r_theta_count = r_theta_count;

				calculate_grid(dims, h_phi, h_theta, r, grid_type);

				f = fopen(grid_h_file, "w");
				fprintf(f, "Polefigures\n");
				fprintf(f,
								"# This file was automatically generated by calculateX.\n");
				fprintf(f, "# grid_type: %d (%s)\n", grid_type,
								grid_descr[grid_type]);
				fprintf(f, "# h_phi_count: %d h_theta_count: %d\n", h_phi_count,
								h_theta_count);
				write_h(N1, h_phi, h_theta, f);
				fclose(f);

				f = fopen(grid_r_file, "w");
				fprintf(f, "Nodes\n");
				fprintf(f,
								"# This file was automatically generated by calculateX.\n");
				fprintf(f, "# grid_type: %d (%s)\n", grid_type,
								grid_descr[grid_type]);
				fprintf(f, "# r_phi_count: %d r_theta_count: %d\n", r_phi_count,
								r_theta_count);
				write_r(N2, r, f);
				fclose(f);
				break;
			}
			default:
				error("Illegal grid type!\n");
		}
		fflush(0);

		calculate_x();

		write_x(N1, N2, x, stdout);

		cleanup();

	} else {
		usage();
	}

	return 0;
}
